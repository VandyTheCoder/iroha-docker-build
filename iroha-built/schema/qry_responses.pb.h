// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qry_responses.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_qry_5fresponses_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_qry_5fresponses_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "block.pb.h"
#include "transaction.pb.h"
#include "primitive.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_qry_5fresponses_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_qry_5fresponses_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[23]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_qry_5fresponses_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_qry_5fresponses_2eproto_metadata_getter(int index);
namespace iroha {
namespace protocol {
class Account;
struct AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class AccountAsset;
struct AccountAssetDefaultTypeInternal;
extern AccountAssetDefaultTypeInternal _AccountAsset_default_instance_;
class AccountAssetResponse;
struct AccountAssetResponseDefaultTypeInternal;
extern AccountAssetResponseDefaultTypeInternal _AccountAssetResponse_default_instance_;
class AccountDetailResponse;
struct AccountDetailResponseDefaultTypeInternal;
extern AccountDetailResponseDefaultTypeInternal _AccountDetailResponse_default_instance_;
class AccountResponse;
struct AccountResponseDefaultTypeInternal;
extern AccountResponseDefaultTypeInternal _AccountResponse_default_instance_;
class Asset;
struct AssetDefaultTypeInternal;
extern AssetDefaultTypeInternal _Asset_default_instance_;
class AssetResponse;
struct AssetResponseDefaultTypeInternal;
extern AssetResponseDefaultTypeInternal _AssetResponse_default_instance_;
class BlockErrorResponse;
struct BlockErrorResponseDefaultTypeInternal;
extern BlockErrorResponseDefaultTypeInternal _BlockErrorResponse_default_instance_;
class BlockQueryResponse;
struct BlockQueryResponseDefaultTypeInternal;
extern BlockQueryResponseDefaultTypeInternal _BlockQueryResponse_default_instance_;
class BlockResponse;
struct BlockResponseDefaultTypeInternal;
extern BlockResponseDefaultTypeInternal _BlockResponse_default_instance_;
class Domain;
struct DomainDefaultTypeInternal;
extern DomainDefaultTypeInternal _Domain_default_instance_;
class EngineReceiptsResponse;
struct EngineReceiptsResponseDefaultTypeInternal;
extern EngineReceiptsResponseDefaultTypeInternal _EngineReceiptsResponse_default_instance_;
class ErrorResponse;
struct ErrorResponseDefaultTypeInternal;
extern ErrorResponseDefaultTypeInternal _ErrorResponse_default_instance_;
class HealthcheckData;
struct HealthcheckDataDefaultTypeInternal;
extern HealthcheckDataDefaultTypeInternal _HealthcheckData_default_instance_;
class PeersResponse;
struct PeersResponseDefaultTypeInternal;
extern PeersResponseDefaultTypeInternal _PeersResponse_default_instance_;
class PendingTransactionsPageResponse;
struct PendingTransactionsPageResponseDefaultTypeInternal;
extern PendingTransactionsPageResponseDefaultTypeInternal _PendingTransactionsPageResponse_default_instance_;
class PendingTransactionsPageResponse_BatchInfo;
struct PendingTransactionsPageResponse_BatchInfoDefaultTypeInternal;
extern PendingTransactionsPageResponse_BatchInfoDefaultTypeInternal _PendingTransactionsPageResponse_BatchInfo_default_instance_;
class QueryResponse;
struct QueryResponseDefaultTypeInternal;
extern QueryResponseDefaultTypeInternal _QueryResponse_default_instance_;
class RolePermissionsResponse;
struct RolePermissionsResponseDefaultTypeInternal;
extern RolePermissionsResponseDefaultTypeInternal _RolePermissionsResponse_default_instance_;
class RolesResponse;
struct RolesResponseDefaultTypeInternal;
extern RolesResponseDefaultTypeInternal _RolesResponse_default_instance_;
class SignatoriesResponse;
struct SignatoriesResponseDefaultTypeInternal;
extern SignatoriesResponseDefaultTypeInternal _SignatoriesResponse_default_instance_;
class TransactionsPageResponse;
struct TransactionsPageResponseDefaultTypeInternal;
extern TransactionsPageResponseDefaultTypeInternal _TransactionsPageResponse_default_instance_;
class TransactionsResponse;
struct TransactionsResponseDefaultTypeInternal;
extern TransactionsResponseDefaultTypeInternal _TransactionsResponse_default_instance_;
}  // namespace protocol
}  // namespace iroha
PROTOBUF_NAMESPACE_OPEN
template<> ::iroha::protocol::Account* Arena::CreateMaybeMessage<::iroha::protocol::Account>(Arena*);
template<> ::iroha::protocol::AccountAsset* Arena::CreateMaybeMessage<::iroha::protocol::AccountAsset>(Arena*);
template<> ::iroha::protocol::AccountAssetResponse* Arena::CreateMaybeMessage<::iroha::protocol::AccountAssetResponse>(Arena*);
template<> ::iroha::protocol::AccountDetailResponse* Arena::CreateMaybeMessage<::iroha::protocol::AccountDetailResponse>(Arena*);
template<> ::iroha::protocol::AccountResponse* Arena::CreateMaybeMessage<::iroha::protocol::AccountResponse>(Arena*);
template<> ::iroha::protocol::Asset* Arena::CreateMaybeMessage<::iroha::protocol::Asset>(Arena*);
template<> ::iroha::protocol::AssetResponse* Arena::CreateMaybeMessage<::iroha::protocol::AssetResponse>(Arena*);
template<> ::iroha::protocol::BlockErrorResponse* Arena::CreateMaybeMessage<::iroha::protocol::BlockErrorResponse>(Arena*);
template<> ::iroha::protocol::BlockQueryResponse* Arena::CreateMaybeMessage<::iroha::protocol::BlockQueryResponse>(Arena*);
template<> ::iroha::protocol::BlockResponse* Arena::CreateMaybeMessage<::iroha::protocol::BlockResponse>(Arena*);
template<> ::iroha::protocol::Domain* Arena::CreateMaybeMessage<::iroha::protocol::Domain>(Arena*);
template<> ::iroha::protocol::EngineReceiptsResponse* Arena::CreateMaybeMessage<::iroha::protocol::EngineReceiptsResponse>(Arena*);
template<> ::iroha::protocol::ErrorResponse* Arena::CreateMaybeMessage<::iroha::protocol::ErrorResponse>(Arena*);
template<> ::iroha::protocol::HealthcheckData* Arena::CreateMaybeMessage<::iroha::protocol::HealthcheckData>(Arena*);
template<> ::iroha::protocol::PeersResponse* Arena::CreateMaybeMessage<::iroha::protocol::PeersResponse>(Arena*);
template<> ::iroha::protocol::PendingTransactionsPageResponse* Arena::CreateMaybeMessage<::iroha::protocol::PendingTransactionsPageResponse>(Arena*);
template<> ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* Arena::CreateMaybeMessage<::iroha::protocol::PendingTransactionsPageResponse_BatchInfo>(Arena*);
template<> ::iroha::protocol::QueryResponse* Arena::CreateMaybeMessage<::iroha::protocol::QueryResponse>(Arena*);
template<> ::iroha::protocol::RolePermissionsResponse* Arena::CreateMaybeMessage<::iroha::protocol::RolePermissionsResponse>(Arena*);
template<> ::iroha::protocol::RolesResponse* Arena::CreateMaybeMessage<::iroha::protocol::RolesResponse>(Arena*);
template<> ::iroha::protocol::SignatoriesResponse* Arena::CreateMaybeMessage<::iroha::protocol::SignatoriesResponse>(Arena*);
template<> ::iroha::protocol::TransactionsPageResponse* Arena::CreateMaybeMessage<::iroha::protocol::TransactionsPageResponse>(Arena*);
template<> ::iroha::protocol::TransactionsResponse* Arena::CreateMaybeMessage<::iroha::protocol::TransactionsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace iroha {
namespace protocol {

enum ErrorResponse_Reason : int {
  ErrorResponse_Reason_STATELESS_INVALID = 0,
  ErrorResponse_Reason_STATEFUL_INVALID = 1,
  ErrorResponse_Reason_NO_ACCOUNT = 2,
  ErrorResponse_Reason_NO_ACCOUNT_ASSETS = 3,
  ErrorResponse_Reason_NO_ACCOUNT_DETAIL = 4,
  ErrorResponse_Reason_NO_SIGNATORIES = 5,
  ErrorResponse_Reason_NOT_SUPPORTED = 6,
  ErrorResponse_Reason_NO_ASSET = 7,
  ErrorResponse_Reason_NO_ROLES = 8,
  ErrorResponse_Reason_ErrorResponse_Reason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ErrorResponse_Reason_ErrorResponse_Reason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ErrorResponse_Reason_IsValid(int value);
constexpr ErrorResponse_Reason ErrorResponse_Reason_Reason_MIN = ErrorResponse_Reason_STATELESS_INVALID;
constexpr ErrorResponse_Reason ErrorResponse_Reason_Reason_MAX = ErrorResponse_Reason_NO_ROLES;
constexpr int ErrorResponse_Reason_Reason_ARRAYSIZE = ErrorResponse_Reason_Reason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorResponse_Reason_descriptor();
template<typename T>
inline const std::string& ErrorResponse_Reason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorResponse_Reason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorResponse_Reason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorResponse_Reason_descriptor(), enum_t_value);
}
inline bool ErrorResponse_Reason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorResponse_Reason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorResponse_Reason>(
    ErrorResponse_Reason_descriptor(), name, value);
}
// ===================================================================

class Asset PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Asset) */ {
 public:
  inline Asset() : Asset(nullptr) {}
  virtual ~Asset();
  explicit constexpr Asset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Asset(const Asset& from);
  Asset(Asset&& from) noexcept
    : Asset() {
    *this = ::std::move(from);
  }

  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }
  inline Asset& operator=(Asset&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Asset& default_instance() {
    return *internal_default_instance();
  }
  static inline const Asset* internal_default_instance() {
    return reinterpret_cast<const Asset*>(
               &_Asset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Asset& a, Asset& b) {
    a.Swap(&b);
  }
  inline void Swap(Asset* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Asset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Asset* New() const final {
    return CreateMaybeMessage<Asset>(nullptr);
  }

  Asset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Asset>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Asset& from);
  void MergeFrom(const Asset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Asset* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.Asset";
  }
  protected:
  explicit Asset(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIdFieldNumber = 1,
    kDomainIdFieldNumber = 2,
    kPrecisionFieldNumber = 3,
  };
  // string asset_id = 1;
  void clear_asset_id();
  const std::string& asset_id() const;
  void set_asset_id(const std::string& value);
  void set_asset_id(std::string&& value);
  void set_asset_id(const char* value);
  void set_asset_id(const char* value, size_t size);
  std::string* mutable_asset_id();
  std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // string domain_id = 2;
  void clear_domain_id();
  const std::string& domain_id() const;
  void set_domain_id(const std::string& value);
  void set_domain_id(std::string&& value);
  void set_domain_id(const char* value);
  void set_domain_id(const char* value, size_t size);
  std::string* mutable_domain_id();
  std::string* release_domain_id();
  void set_allocated_domain_id(std::string* domain_id);
  private:
  const std::string& _internal_domain_id() const;
  void _internal_set_domain_id(const std::string& value);
  std::string* _internal_mutable_domain_id();
  public:

  // uint32 precision = 3;
  void clear_precision();
  ::PROTOBUF_NAMESPACE_ID::uint32 precision() const;
  void set_precision(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_precision() const;
  void _internal_set_precision(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.Asset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 precision_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class Domain PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Domain) */ {
 public:
  inline Domain() : Domain(nullptr) {}
  virtual ~Domain();
  explicit constexpr Domain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Domain(const Domain& from);
  Domain(Domain&& from) noexcept
    : Domain() {
    *this = ::std::move(from);
  }

  inline Domain& operator=(const Domain& from) {
    CopyFrom(from);
    return *this;
  }
  inline Domain& operator=(Domain&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Domain& default_instance() {
    return *internal_default_instance();
  }
  static inline const Domain* internal_default_instance() {
    return reinterpret_cast<const Domain*>(
               &_Domain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Domain& a, Domain& b) {
    a.Swap(&b);
  }
  inline void Swap(Domain* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Domain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Domain* New() const final {
    return CreateMaybeMessage<Domain>(nullptr);
  }

  Domain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Domain>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Domain& from);
  void MergeFrom(const Domain& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Domain* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.Domain";
  }
  protected:
  explicit Domain(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDomainIdFieldNumber = 1,
    kDefaultRoleFieldNumber = 2,
  };
  // string domain_id = 1;
  void clear_domain_id();
  const std::string& domain_id() const;
  void set_domain_id(const std::string& value);
  void set_domain_id(std::string&& value);
  void set_domain_id(const char* value);
  void set_domain_id(const char* value, size_t size);
  std::string* mutable_domain_id();
  std::string* release_domain_id();
  void set_allocated_domain_id(std::string* domain_id);
  private:
  const std::string& _internal_domain_id() const;
  void _internal_set_domain_id(const std::string& value);
  std::string* _internal_mutable_domain_id();
  public:

  // string default_role = 2;
  void clear_default_role();
  const std::string& default_role() const;
  void set_default_role(const std::string& value);
  void set_default_role(std::string&& value);
  void set_default_role(const char* value);
  void set_default_role(const char* value, size_t size);
  std::string* mutable_default_role();
  std::string* release_default_role();
  void set_allocated_default_role(std::string* default_role);
  private:
  const std::string& _internal_default_role() const;
  void _internal_set_default_role(const std::string& value);
  std::string* _internal_mutable_default_role();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.Domain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_role_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class Account PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.Account) */ {
 public:
  inline Account() : Account(nullptr) {}
  virtual ~Account();
  explicit constexpr Account(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Account(const Account& from);
  Account(Account&& from) noexcept
    : Account() {
    *this = ::std::move(from);
  }

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  inline Account& operator=(Account&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Account& default_instance() {
    return *internal_default_instance();
  }
  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Account& a, Account& b) {
    a.Swap(&b);
  }
  inline void Swap(Account* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Account* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Account* New() const final {
    return CreateMaybeMessage<Account>(nullptr);
  }

  Account* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Account>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Account* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.Account";
  }
  protected:
  explicit Account(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 1,
    kDomainIdFieldNumber = 2,
    kJsonDataFieldNumber = 4,
    kQuorumFieldNumber = 3,
  };
  // string account_id = 1;
  void clear_account_id();
  const std::string& account_id() const;
  void set_account_id(const std::string& value);
  void set_account_id(std::string&& value);
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  std::string* mutable_account_id();
  std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // string domain_id = 2;
  void clear_domain_id();
  const std::string& domain_id() const;
  void set_domain_id(const std::string& value);
  void set_domain_id(std::string&& value);
  void set_domain_id(const char* value);
  void set_domain_id(const char* value, size_t size);
  std::string* mutable_domain_id();
  std::string* release_domain_id();
  void set_allocated_domain_id(std::string* domain_id);
  private:
  const std::string& _internal_domain_id() const;
  void _internal_set_domain_id(const std::string& value);
  std::string* _internal_mutable_domain_id();
  public:

  // string json_data = 4;
  void clear_json_data();
  const std::string& json_data() const;
  void set_json_data(const std::string& value);
  void set_json_data(std::string&& value);
  void set_json_data(const char* value);
  void set_json_data(const char* value, size_t size);
  std::string* mutable_json_data();
  std::string* release_json_data();
  void set_allocated_json_data(std::string* json_data);
  private:
  const std::string& _internal_json_data() const;
  void _internal_set_json_data(const std::string& value);
  std::string* _internal_mutable_json_data();
  public:

  // uint32 quorum = 3;
  void clear_quorum();
  ::PROTOBUF_NAMESPACE_ID::uint32 quorum() const;
  void set_quorum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_quorum() const;
  void _internal_set_quorum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.Account)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 quorum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class AccountAsset PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AccountAsset) */ {
 public:
  inline AccountAsset() : AccountAsset(nullptr) {}
  virtual ~AccountAsset();
  explicit constexpr AccountAsset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountAsset(const AccountAsset& from);
  AccountAsset(AccountAsset&& from) noexcept
    : AccountAsset() {
    *this = ::std::move(from);
  }

  inline AccountAsset& operator=(const AccountAsset& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountAsset& operator=(AccountAsset&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AccountAsset& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountAsset* internal_default_instance() {
    return reinterpret_cast<const AccountAsset*>(
               &_AccountAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AccountAsset& a, AccountAsset& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountAsset* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountAsset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountAsset* New() const final {
    return CreateMaybeMessage<AccountAsset>(nullptr);
  }

  AccountAsset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountAsset>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AccountAsset& from);
  void MergeFrom(const AccountAsset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountAsset* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.AccountAsset";
  }
  protected:
  explicit AccountAsset(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIdFieldNumber = 1,
    kAccountIdFieldNumber = 2,
    kBalanceFieldNumber = 3,
  };
  // string asset_id = 1;
  void clear_asset_id();
  const std::string& asset_id() const;
  void set_asset_id(const std::string& value);
  void set_asset_id(std::string&& value);
  void set_asset_id(const char* value);
  void set_asset_id(const char* value, size_t size);
  std::string* mutable_asset_id();
  std::string* release_asset_id();
  void set_allocated_asset_id(std::string* asset_id);
  private:
  const std::string& _internal_asset_id() const;
  void _internal_set_asset_id(const std::string& value);
  std::string* _internal_mutable_asset_id();
  public:

  // string account_id = 2;
  void clear_account_id();
  const std::string& account_id() const;
  void set_account_id(const std::string& value);
  void set_account_id(std::string&& value);
  void set_account_id(const char* value);
  void set_account_id(const char* value, size_t size);
  std::string* mutable_account_id();
  std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // string balance = 3;
  void clear_balance();
  const std::string& balance() const;
  void set_balance(const std::string& value);
  void set_balance(std::string&& value);
  void set_balance(const char* value);
  void set_balance(const char* value, size_t size);
  std::string* mutable_balance();
  std::string* release_balance();
  void set_allocated_balance(std::string* balance);
  private:
  const std::string& _internal_balance() const;
  void _internal_set_balance(const std::string& value);
  std::string* _internal_mutable_balance();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.AccountAsset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class AccountAssetResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AccountAssetResponse) */ {
 public:
  inline AccountAssetResponse() : AccountAssetResponse(nullptr) {}
  virtual ~AccountAssetResponse();
  explicit constexpr AccountAssetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountAssetResponse(const AccountAssetResponse& from);
  AccountAssetResponse(AccountAssetResponse&& from) noexcept
    : AccountAssetResponse() {
    *this = ::std::move(from);
  }

  inline AccountAssetResponse& operator=(const AccountAssetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountAssetResponse& operator=(AccountAssetResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AccountAssetResponse& default_instance() {
    return *internal_default_instance();
  }
  enum OptNextAssetIdCase {
    kNextAssetId = 3,
    OPT_NEXT_ASSET_ID_NOT_SET = 0,
  };

  static inline const AccountAssetResponse* internal_default_instance() {
    return reinterpret_cast<const AccountAssetResponse*>(
               &_AccountAssetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AccountAssetResponse& a, AccountAssetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountAssetResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountAssetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountAssetResponse* New() const final {
    return CreateMaybeMessage<AccountAssetResponse>(nullptr);
  }

  AccountAssetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountAssetResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AccountAssetResponse& from);
  void MergeFrom(const AccountAssetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountAssetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.AccountAssetResponse";
  }
  protected:
  explicit AccountAssetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountAssetsFieldNumber = 1,
    kTotalNumberFieldNumber = 2,
    kNextAssetIdFieldNumber = 3,
  };
  // repeated .iroha.protocol.AccountAsset account_assets = 1;
  int account_assets_size() const;
  private:
  int _internal_account_assets_size() const;
  public:
  void clear_account_assets();
  ::iroha::protocol::AccountAsset* mutable_account_assets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::AccountAsset >*
      mutable_account_assets();
  private:
  const ::iroha::protocol::AccountAsset& _internal_account_assets(int index) const;
  ::iroha::protocol::AccountAsset* _internal_add_account_assets();
  public:
  const ::iroha::protocol::AccountAsset& account_assets(int index) const;
  ::iroha::protocol::AccountAsset* add_account_assets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::AccountAsset >&
      account_assets() const;

  // uint32 total_number = 2;
  void clear_total_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 total_number() const;
  void set_total_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_total_number() const;
  void _internal_set_total_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // string next_asset_id = 3;
  bool has_next_asset_id() const;
  private:
  bool _internal_has_next_asset_id() const;
  public:
  void clear_next_asset_id();
  const std::string& next_asset_id() const;
  void set_next_asset_id(const std::string& value);
  void set_next_asset_id(std::string&& value);
  void set_next_asset_id(const char* value);
  void set_next_asset_id(const char* value, size_t size);
  std::string* mutable_next_asset_id();
  std::string* release_next_asset_id();
  void set_allocated_next_asset_id(std::string* next_asset_id);
  private:
  const std::string& _internal_next_asset_id() const;
  void _internal_set_next_asset_id(const std::string& value);
  std::string* _internal_mutable_next_asset_id();
  public:

  void clear_opt_next_asset_id();
  OptNextAssetIdCase opt_next_asset_id_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.AccountAssetResponse)
 private:
  class _Internal;
  void set_has_next_asset_id();

  inline bool has_opt_next_asset_id() const;
  inline void clear_has_opt_next_asset_id();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::AccountAsset > account_assets_;
  ::PROTOBUF_NAMESPACE_ID::uint32 total_number_;
  union OptNextAssetIdUnion {
    constexpr OptNextAssetIdUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_asset_id_;
  } opt_next_asset_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class AccountDetailResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AccountDetailResponse) */ {
 public:
  inline AccountDetailResponse() : AccountDetailResponse(nullptr) {}
  virtual ~AccountDetailResponse();
  explicit constexpr AccountDetailResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountDetailResponse(const AccountDetailResponse& from);
  AccountDetailResponse(AccountDetailResponse&& from) noexcept
    : AccountDetailResponse() {
    *this = ::std::move(from);
  }

  inline AccountDetailResponse& operator=(const AccountDetailResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountDetailResponse& operator=(AccountDetailResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AccountDetailResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountDetailResponse* internal_default_instance() {
    return reinterpret_cast<const AccountDetailResponse*>(
               &_AccountDetailResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AccountDetailResponse& a, AccountDetailResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountDetailResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountDetailResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountDetailResponse* New() const final {
    return CreateMaybeMessage<AccountDetailResponse>(nullptr);
  }

  AccountDetailResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountDetailResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AccountDetailResponse& from);
  void MergeFrom(const AccountDetailResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountDetailResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.AccountDetailResponse";
  }
  protected:
  explicit AccountDetailResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailFieldNumber = 1,
    kNextRecordIdFieldNumber = 3,
    kTotalNumberFieldNumber = 2,
  };
  // string detail = 1;
  void clear_detail();
  const std::string& detail() const;
  void set_detail(const std::string& value);
  void set_detail(std::string&& value);
  void set_detail(const char* value);
  void set_detail(const char* value, size_t size);
  std::string* mutable_detail();
  std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // .iroha.protocol.AccountDetailRecordId next_record_id = 3;
  bool has_next_record_id() const;
  private:
  bool _internal_has_next_record_id() const;
  public:
  void clear_next_record_id();
  const ::iroha::protocol::AccountDetailRecordId& next_record_id() const;
  ::iroha::protocol::AccountDetailRecordId* release_next_record_id();
  ::iroha::protocol::AccountDetailRecordId* mutable_next_record_id();
  void set_allocated_next_record_id(::iroha::protocol::AccountDetailRecordId* next_record_id);
  private:
  const ::iroha::protocol::AccountDetailRecordId& _internal_next_record_id() const;
  ::iroha::protocol::AccountDetailRecordId* _internal_mutable_next_record_id();
  public:
  void unsafe_arena_set_allocated_next_record_id(
      ::iroha::protocol::AccountDetailRecordId* next_record_id);
  ::iroha::protocol::AccountDetailRecordId* unsafe_arena_release_next_record_id();

  // uint64 total_number = 2;
  void clear_total_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 total_number() const;
  void set_total_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_total_number() const;
  void _internal_set_total_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.AccountDetailResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
  ::iroha::protocol::AccountDetailRecordId* next_record_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 total_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class AccountResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AccountResponse) */ {
 public:
  inline AccountResponse() : AccountResponse(nullptr) {}
  virtual ~AccountResponse();
  explicit constexpr AccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountResponse(const AccountResponse& from);
  AccountResponse(AccountResponse&& from) noexcept
    : AccountResponse() {
    *this = ::std::move(from);
  }

  inline AccountResponse& operator=(const AccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountResponse& operator=(AccountResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountResponse* internal_default_instance() {
    return reinterpret_cast<const AccountResponse*>(
               &_AccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AccountResponse& a, AccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountResponse* New() const final {
    return CreateMaybeMessage<AccountResponse>(nullptr);
  }

  AccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AccountResponse& from);
  void MergeFrom(const AccountResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.AccountResponse";
  }
  protected:
  explicit AccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountRolesFieldNumber = 2,
    kAccountFieldNumber = 1,
  };
  // repeated string account_roles = 2;
  int account_roles_size() const;
  private:
  int _internal_account_roles_size() const;
  public:
  void clear_account_roles();
  const std::string& account_roles(int index) const;
  std::string* mutable_account_roles(int index);
  void set_account_roles(int index, const std::string& value);
  void set_account_roles(int index, std::string&& value);
  void set_account_roles(int index, const char* value);
  void set_account_roles(int index, const char* value, size_t size);
  std::string* add_account_roles();
  void add_account_roles(const std::string& value);
  void add_account_roles(std::string&& value);
  void add_account_roles(const char* value);
  void add_account_roles(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& account_roles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_account_roles();
  private:
  const std::string& _internal_account_roles(int index) const;
  std::string* _internal_add_account_roles();
  public:

  // .iroha.protocol.Account account = 1;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::iroha::protocol::Account& account() const;
  ::iroha::protocol::Account* release_account();
  ::iroha::protocol::Account* mutable_account();
  void set_allocated_account(::iroha::protocol::Account* account);
  private:
  const ::iroha::protocol::Account& _internal_account() const;
  ::iroha::protocol::Account* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::iroha::protocol::Account* account);
  ::iroha::protocol::Account* unsafe_arena_release_account();

  // @@protoc_insertion_point(class_scope:iroha.protocol.AccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> account_roles_;
  ::iroha::protocol::Account* account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class AssetResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.AssetResponse) */ {
 public:
  inline AssetResponse() : AssetResponse(nullptr) {}
  virtual ~AssetResponse();
  explicit constexpr AssetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetResponse(const AssetResponse& from);
  AssetResponse(AssetResponse&& from) noexcept
    : AssetResponse() {
    *this = ::std::move(from);
  }

  inline AssetResponse& operator=(const AssetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetResponse& operator=(AssetResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AssetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetResponse* internal_default_instance() {
    return reinterpret_cast<const AssetResponse*>(
               &_AssetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AssetResponse& a, AssetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AssetResponse* New() const final {
    return CreateMaybeMessage<AssetResponse>(nullptr);
  }

  AssetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AssetResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AssetResponse& from);
  void MergeFrom(const AssetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.AssetResponse";
  }
  protected:
  explicit AssetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetFieldNumber = 1,
  };
  // .iroha.protocol.Asset asset = 1;
  bool has_asset() const;
  private:
  bool _internal_has_asset() const;
  public:
  void clear_asset();
  const ::iroha::protocol::Asset& asset() const;
  ::iroha::protocol::Asset* release_asset();
  ::iroha::protocol::Asset* mutable_asset();
  void set_allocated_asset(::iroha::protocol::Asset* asset);
  private:
  const ::iroha::protocol::Asset& _internal_asset() const;
  ::iroha::protocol::Asset* _internal_mutable_asset();
  public:
  void unsafe_arena_set_allocated_asset(
      ::iroha::protocol::Asset* asset);
  ::iroha::protocol::Asset* unsafe_arena_release_asset();

  // @@protoc_insertion_point(class_scope:iroha.protocol.AssetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::iroha::protocol::Asset* asset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class RolesResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.RolesResponse) */ {
 public:
  inline RolesResponse() : RolesResponse(nullptr) {}
  virtual ~RolesResponse();
  explicit constexpr RolesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RolesResponse(const RolesResponse& from);
  RolesResponse(RolesResponse&& from) noexcept
    : RolesResponse() {
    *this = ::std::move(from);
  }

  inline RolesResponse& operator=(const RolesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RolesResponse& operator=(RolesResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RolesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RolesResponse* internal_default_instance() {
    return reinterpret_cast<const RolesResponse*>(
               &_RolesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RolesResponse& a, RolesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RolesResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RolesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RolesResponse* New() const final {
    return CreateMaybeMessage<RolesResponse>(nullptr);
  }

  RolesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RolesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RolesResponse& from);
  void MergeFrom(const RolesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RolesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.RolesResponse";
  }
  protected:
  explicit RolesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 1,
  };
  // repeated string roles = 1;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  const std::string& roles(int index) const;
  std::string* mutable_roles(int index);
  void set_roles(int index, const std::string& value);
  void set_roles(int index, std::string&& value);
  void set_roles(int index, const char* value);
  void set_roles(int index, const char* value, size_t size);
  std::string* add_roles();
  void add_roles(const std::string& value);
  void add_roles(std::string&& value);
  void add_roles(const char* value);
  void add_roles(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& roles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_roles();
  private:
  const std::string& _internal_roles(int index) const;
  std::string* _internal_add_roles();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.RolesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> roles_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class RolePermissionsResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.RolePermissionsResponse) */ {
 public:
  inline RolePermissionsResponse() : RolePermissionsResponse(nullptr) {}
  virtual ~RolePermissionsResponse();
  explicit constexpr RolePermissionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RolePermissionsResponse(const RolePermissionsResponse& from);
  RolePermissionsResponse(RolePermissionsResponse&& from) noexcept
    : RolePermissionsResponse() {
    *this = ::std::move(from);
  }

  inline RolePermissionsResponse& operator=(const RolePermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RolePermissionsResponse& operator=(RolePermissionsResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RolePermissionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RolePermissionsResponse* internal_default_instance() {
    return reinterpret_cast<const RolePermissionsResponse*>(
               &_RolePermissionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RolePermissionsResponse& a, RolePermissionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RolePermissionsResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RolePermissionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RolePermissionsResponse* New() const final {
    return CreateMaybeMessage<RolePermissionsResponse>(nullptr);
  }

  RolePermissionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RolePermissionsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RolePermissionsResponse& from);
  void MergeFrom(const RolePermissionsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RolePermissionsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.RolePermissionsResponse";
  }
  protected:
  explicit RolePermissionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 1,
  };
  // repeated .iroha.protocol.RolePermission permissions = 1;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  private:
  ::iroha::protocol::RolePermission _internal_permissions(int index) const;
  void _internal_add_permissions(::iroha::protocol::RolePermission value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_permissions();
  public:
  ::iroha::protocol::RolePermission permissions(int index) const;
  void set_permissions(int index, ::iroha::protocol::RolePermission value);
  void add_permissions(::iroha::protocol::RolePermission value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_permissions();

  // @@protoc_insertion_point(class_scope:iroha.protocol.RolePermissionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> permissions_;
  mutable std::atomic<int> _permissions_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class ErrorResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.ErrorResponse) */ {
 public:
  inline ErrorResponse() : ErrorResponse(nullptr) {}
  virtual ~ErrorResponse();
  explicit constexpr ErrorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorResponse(const ErrorResponse& from);
  ErrorResponse(ErrorResponse&& from) noexcept
    : ErrorResponse() {
    *this = ::std::move(from);
  }

  inline ErrorResponse& operator=(const ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorResponse& operator=(ErrorResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ErrorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorResponse* internal_default_instance() {
    return reinterpret_cast<const ErrorResponse*>(
               &_ErrorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ErrorResponse& a, ErrorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrorResponse* New() const final {
    return CreateMaybeMessage<ErrorResponse>(nullptr);
  }

  ErrorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrorResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ErrorResponse& from);
  void MergeFrom(const ErrorResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.ErrorResponse";
  }
  protected:
  explicit ErrorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  typedef ErrorResponse_Reason Reason;
  static constexpr Reason STATELESS_INVALID =
    ErrorResponse_Reason_STATELESS_INVALID;
  static constexpr Reason STATEFUL_INVALID =
    ErrorResponse_Reason_STATEFUL_INVALID;
  static constexpr Reason NO_ACCOUNT =
    ErrorResponse_Reason_NO_ACCOUNT;
  static constexpr Reason NO_ACCOUNT_ASSETS =
    ErrorResponse_Reason_NO_ACCOUNT_ASSETS;
  static constexpr Reason NO_ACCOUNT_DETAIL =
    ErrorResponse_Reason_NO_ACCOUNT_DETAIL;
  static constexpr Reason NO_SIGNATORIES =
    ErrorResponse_Reason_NO_SIGNATORIES;
  static constexpr Reason NOT_SUPPORTED =
    ErrorResponse_Reason_NOT_SUPPORTED;
  static constexpr Reason NO_ASSET =
    ErrorResponse_Reason_NO_ASSET;
  static constexpr Reason NO_ROLES =
    ErrorResponse_Reason_NO_ROLES;
  static inline bool Reason_IsValid(int value) {
    return ErrorResponse_Reason_IsValid(value);
  }
  static constexpr Reason Reason_MIN =
    ErrorResponse_Reason_Reason_MIN;
  static constexpr Reason Reason_MAX =
    ErrorResponse_Reason_Reason_MAX;
  static constexpr int Reason_ARRAYSIZE =
    ErrorResponse_Reason_Reason_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Reason_descriptor() {
    return ErrorResponse_Reason_descriptor();
  }
  template<typename T>
  static inline const std::string& Reason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Reason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Reason_Name.");
    return ErrorResponse_Reason_Name(enum_t_value);
  }
  static inline bool Reason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Reason* value) {
    return ErrorResponse_Reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kReasonFieldNumber = 1,
    kErrorCodeFieldNumber = 3,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .iroha.protocol.ErrorResponse.Reason reason = 1;
  void clear_reason();
  ::iroha::protocol::ErrorResponse_Reason reason() const;
  void set_reason(::iroha::protocol::ErrorResponse_Reason value);
  private:
  ::iroha::protocol::ErrorResponse_Reason _internal_reason() const;
  void _internal_set_reason(::iroha::protocol::ErrorResponse_Reason value);
  public:

  // uint32 error_code = 3;
  void clear_error_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 error_code() const;
  void set_error_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_error_code() const;
  void _internal_set_error_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.ErrorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int reason_;
  ::PROTOBUF_NAMESPACE_ID::uint32 error_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class SignatoriesResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.SignatoriesResponse) */ {
 public:
  inline SignatoriesResponse() : SignatoriesResponse(nullptr) {}
  virtual ~SignatoriesResponse();
  explicit constexpr SignatoriesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignatoriesResponse(const SignatoriesResponse& from);
  SignatoriesResponse(SignatoriesResponse&& from) noexcept
    : SignatoriesResponse() {
    *this = ::std::move(from);
  }

  inline SignatoriesResponse& operator=(const SignatoriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignatoriesResponse& operator=(SignatoriesResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignatoriesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignatoriesResponse* internal_default_instance() {
    return reinterpret_cast<const SignatoriesResponse*>(
               &_SignatoriesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SignatoriesResponse& a, SignatoriesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignatoriesResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignatoriesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignatoriesResponse* New() const final {
    return CreateMaybeMessage<SignatoriesResponse>(nullptr);
  }

  SignatoriesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignatoriesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignatoriesResponse& from);
  void MergeFrom(const SignatoriesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignatoriesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.SignatoriesResponse";
  }
  protected:
  explicit SignatoriesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated string keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.SignatoriesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class TransactionsResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.TransactionsResponse) */ {
 public:
  inline TransactionsResponse() : TransactionsResponse(nullptr) {}
  virtual ~TransactionsResponse();
  explicit constexpr TransactionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionsResponse(const TransactionsResponse& from);
  TransactionsResponse(TransactionsResponse&& from) noexcept
    : TransactionsResponse() {
    *this = ::std::move(from);
  }

  inline TransactionsResponse& operator=(const TransactionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionsResponse& operator=(TransactionsResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransactionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionsResponse* internal_default_instance() {
    return reinterpret_cast<const TransactionsResponse*>(
               &_TransactionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TransactionsResponse& a, TransactionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionsResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionsResponse* New() const final {
    return CreateMaybeMessage<TransactionsResponse>(nullptr);
  }

  TransactionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransactionsResponse& from);
  void MergeFrom(const TransactionsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.TransactionsResponse";
  }
  protected:
  explicit TransactionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 1,
  };
  // repeated .iroha.protocol.Transaction transactions = 1;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  ::iroha::protocol::Transaction* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction >*
      mutable_transactions();
  private:
  const ::iroha::protocol::Transaction& _internal_transactions(int index) const;
  ::iroha::protocol::Transaction* _internal_add_transactions();
  public:
  const ::iroha::protocol::Transaction& transactions(int index) const;
  ::iroha::protocol::Transaction* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction >&
      transactions() const;

  // @@protoc_insertion_point(class_scope:iroha.protocol.TransactionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction > transactions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class TransactionsPageResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.TransactionsPageResponse) */ {
 public:
  inline TransactionsPageResponse() : TransactionsPageResponse(nullptr) {}
  virtual ~TransactionsPageResponse();
  explicit constexpr TransactionsPageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionsPageResponse(const TransactionsPageResponse& from);
  TransactionsPageResponse(TransactionsPageResponse&& from) noexcept
    : TransactionsPageResponse() {
    *this = ::std::move(from);
  }

  inline TransactionsPageResponse& operator=(const TransactionsPageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionsPageResponse& operator=(TransactionsPageResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransactionsPageResponse& default_instance() {
    return *internal_default_instance();
  }
  enum NextPageTagCase {
    kNextTxHash = 3,
    NEXT_PAGE_TAG_NOT_SET = 0,
  };

  static inline const TransactionsPageResponse* internal_default_instance() {
    return reinterpret_cast<const TransactionsPageResponse*>(
               &_TransactionsPageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TransactionsPageResponse& a, TransactionsPageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionsPageResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionsPageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionsPageResponse* New() const final {
    return CreateMaybeMessage<TransactionsPageResponse>(nullptr);
  }

  TransactionsPageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionsPageResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransactionsPageResponse& from);
  void MergeFrom(const TransactionsPageResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionsPageResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.TransactionsPageResponse";
  }
  protected:
  explicit TransactionsPageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 1,
    kAllTransactionsSizeFieldNumber = 2,
    kNextTxHashFieldNumber = 3,
  };
  // repeated .iroha.protocol.Transaction transactions = 1;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  ::iroha::protocol::Transaction* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction >*
      mutable_transactions();
  private:
  const ::iroha::protocol::Transaction& _internal_transactions(int index) const;
  ::iroha::protocol::Transaction* _internal_add_transactions();
  public:
  const ::iroha::protocol::Transaction& transactions(int index) const;
  ::iroha::protocol::Transaction* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction >&
      transactions() const;

  // uint32 all_transactions_size = 2;
  void clear_all_transactions_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 all_transactions_size() const;
  void set_all_transactions_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_all_transactions_size() const;
  void _internal_set_all_transactions_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // string next_tx_hash = 3;
  bool has_next_tx_hash() const;
  private:
  bool _internal_has_next_tx_hash() const;
  public:
  void clear_next_tx_hash();
  const std::string& next_tx_hash() const;
  void set_next_tx_hash(const std::string& value);
  void set_next_tx_hash(std::string&& value);
  void set_next_tx_hash(const char* value);
  void set_next_tx_hash(const char* value, size_t size);
  std::string* mutable_next_tx_hash();
  std::string* release_next_tx_hash();
  void set_allocated_next_tx_hash(std::string* next_tx_hash);
  private:
  const std::string& _internal_next_tx_hash() const;
  void _internal_set_next_tx_hash(const std::string& value);
  std::string* _internal_mutable_next_tx_hash();
  public:

  void clear_next_page_tag();
  NextPageTagCase next_page_tag_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.TransactionsPageResponse)
 private:
  class _Internal;
  void set_has_next_tx_hash();

  inline bool has_next_page_tag() const;
  inline void clear_has_next_page_tag();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction > transactions_;
  ::PROTOBUF_NAMESPACE_ID::uint32 all_transactions_size_;
  union NextPageTagUnion {
    constexpr NextPageTagUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_tx_hash_;
  } next_page_tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class PendingTransactionsPageResponse_BatchInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.PendingTransactionsPageResponse.BatchInfo) */ {
 public:
  inline PendingTransactionsPageResponse_BatchInfo() : PendingTransactionsPageResponse_BatchInfo(nullptr) {}
  virtual ~PendingTransactionsPageResponse_BatchInfo();
  explicit constexpr PendingTransactionsPageResponse_BatchInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PendingTransactionsPageResponse_BatchInfo(const PendingTransactionsPageResponse_BatchInfo& from);
  PendingTransactionsPageResponse_BatchInfo(PendingTransactionsPageResponse_BatchInfo&& from) noexcept
    : PendingTransactionsPageResponse_BatchInfo() {
    *this = ::std::move(from);
  }

  inline PendingTransactionsPageResponse_BatchInfo& operator=(const PendingTransactionsPageResponse_BatchInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PendingTransactionsPageResponse_BatchInfo& operator=(PendingTransactionsPageResponse_BatchInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PendingTransactionsPageResponse_BatchInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PendingTransactionsPageResponse_BatchInfo* internal_default_instance() {
    return reinterpret_cast<const PendingTransactionsPageResponse_BatchInfo*>(
               &_PendingTransactionsPageResponse_BatchInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PendingTransactionsPageResponse_BatchInfo& a, PendingTransactionsPageResponse_BatchInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PendingTransactionsPageResponse_BatchInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PendingTransactionsPageResponse_BatchInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PendingTransactionsPageResponse_BatchInfo* New() const final {
    return CreateMaybeMessage<PendingTransactionsPageResponse_BatchInfo>(nullptr);
  }

  PendingTransactionsPageResponse_BatchInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PendingTransactionsPageResponse_BatchInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PendingTransactionsPageResponse_BatchInfo& from);
  void MergeFrom(const PendingTransactionsPageResponse_BatchInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PendingTransactionsPageResponse_BatchInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.PendingTransactionsPageResponse.BatchInfo";
  }
  protected:
  explicit PendingTransactionsPageResponse_BatchInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstTxHashFieldNumber = 1,
    kBatchSizeFieldNumber = 2,
  };
  // string first_tx_hash = 1;
  void clear_first_tx_hash();
  const std::string& first_tx_hash() const;
  void set_first_tx_hash(const std::string& value);
  void set_first_tx_hash(std::string&& value);
  void set_first_tx_hash(const char* value);
  void set_first_tx_hash(const char* value, size_t size);
  std::string* mutable_first_tx_hash();
  std::string* release_first_tx_hash();
  void set_allocated_first_tx_hash(std::string* first_tx_hash);
  private:
  const std::string& _internal_first_tx_hash() const;
  void _internal_set_first_tx_hash(const std::string& value);
  std::string* _internal_mutable_first_tx_hash();
  public:

  // uint32 batch_size = 2;
  void clear_batch_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 batch_size() const;
  void set_batch_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_batch_size() const;
  void _internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.PendingTransactionsPageResponse.BatchInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_tx_hash_;
  ::PROTOBUF_NAMESPACE_ID::uint32 batch_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class PendingTransactionsPageResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.PendingTransactionsPageResponse) */ {
 public:
  inline PendingTransactionsPageResponse() : PendingTransactionsPageResponse(nullptr) {}
  virtual ~PendingTransactionsPageResponse();
  explicit constexpr PendingTransactionsPageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PendingTransactionsPageResponse(const PendingTransactionsPageResponse& from);
  PendingTransactionsPageResponse(PendingTransactionsPageResponse&& from) noexcept
    : PendingTransactionsPageResponse() {
    *this = ::std::move(from);
  }

  inline PendingTransactionsPageResponse& operator=(const PendingTransactionsPageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PendingTransactionsPageResponse& operator=(PendingTransactionsPageResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PendingTransactionsPageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PendingTransactionsPageResponse* internal_default_instance() {
    return reinterpret_cast<const PendingTransactionsPageResponse*>(
               &_PendingTransactionsPageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PendingTransactionsPageResponse& a, PendingTransactionsPageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PendingTransactionsPageResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PendingTransactionsPageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PendingTransactionsPageResponse* New() const final {
    return CreateMaybeMessage<PendingTransactionsPageResponse>(nullptr);
  }

  PendingTransactionsPageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PendingTransactionsPageResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PendingTransactionsPageResponse& from);
  void MergeFrom(const PendingTransactionsPageResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PendingTransactionsPageResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.PendingTransactionsPageResponse";
  }
  protected:
  explicit PendingTransactionsPageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  typedef PendingTransactionsPageResponse_BatchInfo BatchInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 1,
    kNextBatchInfoFieldNumber = 3,
    kAllTransactionsSizeFieldNumber = 2,
  };
  // repeated .iroha.protocol.Transaction transactions = 1;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  ::iroha::protocol::Transaction* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction >*
      mutable_transactions();
  private:
  const ::iroha::protocol::Transaction& _internal_transactions(int index) const;
  ::iroha::protocol::Transaction* _internal_add_transactions();
  public:
  const ::iroha::protocol::Transaction& transactions(int index) const;
  ::iroha::protocol::Transaction* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction >&
      transactions() const;

  // .iroha.protocol.PendingTransactionsPageResponse.BatchInfo next_batch_info = 3;
  bool has_next_batch_info() const;
  private:
  bool _internal_has_next_batch_info() const;
  public:
  void clear_next_batch_info();
  const ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo& next_batch_info() const;
  ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* release_next_batch_info();
  ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* mutable_next_batch_info();
  void set_allocated_next_batch_info(::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* next_batch_info);
  private:
  const ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo& _internal_next_batch_info() const;
  ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* _internal_mutable_next_batch_info();
  public:
  void unsafe_arena_set_allocated_next_batch_info(
      ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* next_batch_info);
  ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* unsafe_arena_release_next_batch_info();

  // uint32 all_transactions_size = 2;
  void clear_all_transactions_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 all_transactions_size() const;
  void set_all_transactions_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_all_transactions_size() const;
  void _internal_set_all_transactions_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.PendingTransactionsPageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction > transactions_;
  ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* next_batch_info_;
  ::PROTOBUF_NAMESPACE_ID::uint32 all_transactions_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class PeersResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.PeersResponse) */ {
 public:
  inline PeersResponse() : PeersResponse(nullptr) {}
  virtual ~PeersResponse();
  explicit constexpr PeersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeersResponse(const PeersResponse& from);
  PeersResponse(PeersResponse&& from) noexcept
    : PeersResponse() {
    *this = ::std::move(from);
  }

  inline PeersResponse& operator=(const PeersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeersResponse& operator=(PeersResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PeersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeersResponse* internal_default_instance() {
    return reinterpret_cast<const PeersResponse*>(
               &_PeersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PeersResponse& a, PeersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PeersResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PeersResponse* New() const final {
    return CreateMaybeMessage<PeersResponse>(nullptr);
  }

  PeersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PeersResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PeersResponse& from);
  void MergeFrom(const PeersResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeersResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.PeersResponse";
  }
  protected:
  explicit PeersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 1,
  };
  // repeated .iroha.protocol.Peer peers = 1;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::iroha::protocol::Peer* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Peer >*
      mutable_peers();
  private:
  const ::iroha::protocol::Peer& _internal_peers(int index) const;
  ::iroha::protocol::Peer* _internal_add_peers();
  public:
  const ::iroha::protocol::Peer& peers(int index) const;
  ::iroha::protocol::Peer* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Peer >&
      peers() const;

  // @@protoc_insertion_point(class_scope:iroha.protocol.PeersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Peer > peers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class EngineReceiptsResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.EngineReceiptsResponse) */ {
 public:
  inline EngineReceiptsResponse() : EngineReceiptsResponse(nullptr) {}
  virtual ~EngineReceiptsResponse();
  explicit constexpr EngineReceiptsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EngineReceiptsResponse(const EngineReceiptsResponse& from);
  EngineReceiptsResponse(EngineReceiptsResponse&& from) noexcept
    : EngineReceiptsResponse() {
    *this = ::std::move(from);
  }

  inline EngineReceiptsResponse& operator=(const EngineReceiptsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EngineReceiptsResponse& operator=(EngineReceiptsResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EngineReceiptsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EngineReceiptsResponse* internal_default_instance() {
    return reinterpret_cast<const EngineReceiptsResponse*>(
               &_EngineReceiptsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EngineReceiptsResponse& a, EngineReceiptsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EngineReceiptsResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EngineReceiptsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EngineReceiptsResponse* New() const final {
    return CreateMaybeMessage<EngineReceiptsResponse>(nullptr);
  }

  EngineReceiptsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EngineReceiptsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EngineReceiptsResponse& from);
  void MergeFrom(const EngineReceiptsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EngineReceiptsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.EngineReceiptsResponse";
  }
  protected:
  explicit EngineReceiptsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEngineReceiptsFieldNumber = 1,
  };
  // repeated .iroha.protocol.EngineReceipt engine_receipts = 1;
  int engine_receipts_size() const;
  private:
  int _internal_engine_receipts_size() const;
  public:
  void clear_engine_receipts();
  ::iroha::protocol::EngineReceipt* mutable_engine_receipts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::EngineReceipt >*
      mutable_engine_receipts();
  private:
  const ::iroha::protocol::EngineReceipt& _internal_engine_receipts(int index) const;
  ::iroha::protocol::EngineReceipt* _internal_add_engine_receipts();
  public:
  const ::iroha::protocol::EngineReceipt& engine_receipts(int index) const;
  ::iroha::protocol::EngineReceipt* add_engine_receipts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::EngineReceipt >&
      engine_receipts() const;

  // @@protoc_insertion_point(class_scope:iroha.protocol.EngineReceiptsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::EngineReceipt > engine_receipts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class QueryResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.QueryResponse) */ {
 public:
  inline QueryResponse() : QueryResponse(nullptr) {}
  virtual ~QueryResponse();
  explicit constexpr QueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryResponse(const QueryResponse& from);
  QueryResponse(QueryResponse&& from) noexcept
    : QueryResponse() {
    *this = ::std::move(from);
  }

  inline QueryResponse& operator=(const QueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryResponse& operator=(QueryResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QueryResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kAccountAssetsResponse = 1,
    kAccountDetailResponse = 2,
    kAccountResponse = 3,
    kErrorResponse = 4,
    kSignatoriesResponse = 5,
    kTransactionsResponse = 6,
    kAssetResponse = 7,
    kRolesResponse = 8,
    kRolePermissionsResponse = 9,
    kTransactionsPageResponse = 11,
    kPendingTransactionsPageResponse = 13,
    kBlockResponse = 12,
    kPeersResponse = 14,
    kEngineReceiptsResponse = 15,
    RESPONSE_NOT_SET = 0,
  };

  static inline const QueryResponse* internal_default_instance() {
    return reinterpret_cast<const QueryResponse*>(
               &_QueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(QueryResponse& a, QueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryResponse* New() const final {
    return CreateMaybeMessage<QueryResponse>(nullptr);
  }

  QueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QueryResponse& from);
  void MergeFrom(const QueryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.QueryResponse";
  }
  protected:
  explicit QueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryHashFieldNumber = 10,
    kAccountAssetsResponseFieldNumber = 1,
    kAccountDetailResponseFieldNumber = 2,
    kAccountResponseFieldNumber = 3,
    kErrorResponseFieldNumber = 4,
    kSignatoriesResponseFieldNumber = 5,
    kTransactionsResponseFieldNumber = 6,
    kAssetResponseFieldNumber = 7,
    kRolesResponseFieldNumber = 8,
    kRolePermissionsResponseFieldNumber = 9,
    kTransactionsPageResponseFieldNumber = 11,
    kPendingTransactionsPageResponseFieldNumber = 13,
    kBlockResponseFieldNumber = 12,
    kPeersResponseFieldNumber = 14,
    kEngineReceiptsResponseFieldNumber = 15,
  };
  // string query_hash = 10;
  void clear_query_hash();
  const std::string& query_hash() const;
  void set_query_hash(const std::string& value);
  void set_query_hash(std::string&& value);
  void set_query_hash(const char* value);
  void set_query_hash(const char* value, size_t size);
  std::string* mutable_query_hash();
  std::string* release_query_hash();
  void set_allocated_query_hash(std::string* query_hash);
  private:
  const std::string& _internal_query_hash() const;
  void _internal_set_query_hash(const std::string& value);
  std::string* _internal_mutable_query_hash();
  public:

  // .iroha.protocol.AccountAssetResponse account_assets_response = 1;
  bool has_account_assets_response() const;
  private:
  bool _internal_has_account_assets_response() const;
  public:
  void clear_account_assets_response();
  const ::iroha::protocol::AccountAssetResponse& account_assets_response() const;
  ::iroha::protocol::AccountAssetResponse* release_account_assets_response();
  ::iroha::protocol::AccountAssetResponse* mutable_account_assets_response();
  void set_allocated_account_assets_response(::iroha::protocol::AccountAssetResponse* account_assets_response);
  private:
  const ::iroha::protocol::AccountAssetResponse& _internal_account_assets_response() const;
  ::iroha::protocol::AccountAssetResponse* _internal_mutable_account_assets_response();
  public:
  void unsafe_arena_set_allocated_account_assets_response(
      ::iroha::protocol::AccountAssetResponse* account_assets_response);
  ::iroha::protocol::AccountAssetResponse* unsafe_arena_release_account_assets_response();

  // .iroha.protocol.AccountDetailResponse account_detail_response = 2;
  bool has_account_detail_response() const;
  private:
  bool _internal_has_account_detail_response() const;
  public:
  void clear_account_detail_response();
  const ::iroha::protocol::AccountDetailResponse& account_detail_response() const;
  ::iroha::protocol::AccountDetailResponse* release_account_detail_response();
  ::iroha::protocol::AccountDetailResponse* mutable_account_detail_response();
  void set_allocated_account_detail_response(::iroha::protocol::AccountDetailResponse* account_detail_response);
  private:
  const ::iroha::protocol::AccountDetailResponse& _internal_account_detail_response() const;
  ::iroha::protocol::AccountDetailResponse* _internal_mutable_account_detail_response();
  public:
  void unsafe_arena_set_allocated_account_detail_response(
      ::iroha::protocol::AccountDetailResponse* account_detail_response);
  ::iroha::protocol::AccountDetailResponse* unsafe_arena_release_account_detail_response();

  // .iroha.protocol.AccountResponse account_response = 3;
  bool has_account_response() const;
  private:
  bool _internal_has_account_response() const;
  public:
  void clear_account_response();
  const ::iroha::protocol::AccountResponse& account_response() const;
  ::iroha::protocol::AccountResponse* release_account_response();
  ::iroha::protocol::AccountResponse* mutable_account_response();
  void set_allocated_account_response(::iroha::protocol::AccountResponse* account_response);
  private:
  const ::iroha::protocol::AccountResponse& _internal_account_response() const;
  ::iroha::protocol::AccountResponse* _internal_mutable_account_response();
  public:
  void unsafe_arena_set_allocated_account_response(
      ::iroha::protocol::AccountResponse* account_response);
  ::iroha::protocol::AccountResponse* unsafe_arena_release_account_response();

  // .iroha.protocol.ErrorResponse error_response = 4;
  bool has_error_response() const;
  private:
  bool _internal_has_error_response() const;
  public:
  void clear_error_response();
  const ::iroha::protocol::ErrorResponse& error_response() const;
  ::iroha::protocol::ErrorResponse* release_error_response();
  ::iroha::protocol::ErrorResponse* mutable_error_response();
  void set_allocated_error_response(::iroha::protocol::ErrorResponse* error_response);
  private:
  const ::iroha::protocol::ErrorResponse& _internal_error_response() const;
  ::iroha::protocol::ErrorResponse* _internal_mutable_error_response();
  public:
  void unsafe_arena_set_allocated_error_response(
      ::iroha::protocol::ErrorResponse* error_response);
  ::iroha::protocol::ErrorResponse* unsafe_arena_release_error_response();

  // .iroha.protocol.SignatoriesResponse signatories_response = 5;
  bool has_signatories_response() const;
  private:
  bool _internal_has_signatories_response() const;
  public:
  void clear_signatories_response();
  const ::iroha::protocol::SignatoriesResponse& signatories_response() const;
  ::iroha::protocol::SignatoriesResponse* release_signatories_response();
  ::iroha::protocol::SignatoriesResponse* mutable_signatories_response();
  void set_allocated_signatories_response(::iroha::protocol::SignatoriesResponse* signatories_response);
  private:
  const ::iroha::protocol::SignatoriesResponse& _internal_signatories_response() const;
  ::iroha::protocol::SignatoriesResponse* _internal_mutable_signatories_response();
  public:
  void unsafe_arena_set_allocated_signatories_response(
      ::iroha::protocol::SignatoriesResponse* signatories_response);
  ::iroha::protocol::SignatoriesResponse* unsafe_arena_release_signatories_response();

  // .iroha.protocol.TransactionsResponse transactions_response = 6;
  bool has_transactions_response() const;
  private:
  bool _internal_has_transactions_response() const;
  public:
  void clear_transactions_response();
  const ::iroha::protocol::TransactionsResponse& transactions_response() const;
  ::iroha::protocol::TransactionsResponse* release_transactions_response();
  ::iroha::protocol::TransactionsResponse* mutable_transactions_response();
  void set_allocated_transactions_response(::iroha::protocol::TransactionsResponse* transactions_response);
  private:
  const ::iroha::protocol::TransactionsResponse& _internal_transactions_response() const;
  ::iroha::protocol::TransactionsResponse* _internal_mutable_transactions_response();
  public:
  void unsafe_arena_set_allocated_transactions_response(
      ::iroha::protocol::TransactionsResponse* transactions_response);
  ::iroha::protocol::TransactionsResponse* unsafe_arena_release_transactions_response();

  // .iroha.protocol.AssetResponse asset_response = 7;
  bool has_asset_response() const;
  private:
  bool _internal_has_asset_response() const;
  public:
  void clear_asset_response();
  const ::iroha::protocol::AssetResponse& asset_response() const;
  ::iroha::protocol::AssetResponse* release_asset_response();
  ::iroha::protocol::AssetResponse* mutable_asset_response();
  void set_allocated_asset_response(::iroha::protocol::AssetResponse* asset_response);
  private:
  const ::iroha::protocol::AssetResponse& _internal_asset_response() const;
  ::iroha::protocol::AssetResponse* _internal_mutable_asset_response();
  public:
  void unsafe_arena_set_allocated_asset_response(
      ::iroha::protocol::AssetResponse* asset_response);
  ::iroha::protocol::AssetResponse* unsafe_arena_release_asset_response();

  // .iroha.protocol.RolesResponse roles_response = 8;
  bool has_roles_response() const;
  private:
  bool _internal_has_roles_response() const;
  public:
  void clear_roles_response();
  const ::iroha::protocol::RolesResponse& roles_response() const;
  ::iroha::protocol::RolesResponse* release_roles_response();
  ::iroha::protocol::RolesResponse* mutable_roles_response();
  void set_allocated_roles_response(::iroha::protocol::RolesResponse* roles_response);
  private:
  const ::iroha::protocol::RolesResponse& _internal_roles_response() const;
  ::iroha::protocol::RolesResponse* _internal_mutable_roles_response();
  public:
  void unsafe_arena_set_allocated_roles_response(
      ::iroha::protocol::RolesResponse* roles_response);
  ::iroha::protocol::RolesResponse* unsafe_arena_release_roles_response();

  // .iroha.protocol.RolePermissionsResponse role_permissions_response = 9;
  bool has_role_permissions_response() const;
  private:
  bool _internal_has_role_permissions_response() const;
  public:
  void clear_role_permissions_response();
  const ::iroha::protocol::RolePermissionsResponse& role_permissions_response() const;
  ::iroha::protocol::RolePermissionsResponse* release_role_permissions_response();
  ::iroha::protocol::RolePermissionsResponse* mutable_role_permissions_response();
  void set_allocated_role_permissions_response(::iroha::protocol::RolePermissionsResponse* role_permissions_response);
  private:
  const ::iroha::protocol::RolePermissionsResponse& _internal_role_permissions_response() const;
  ::iroha::protocol::RolePermissionsResponse* _internal_mutable_role_permissions_response();
  public:
  void unsafe_arena_set_allocated_role_permissions_response(
      ::iroha::protocol::RolePermissionsResponse* role_permissions_response);
  ::iroha::protocol::RolePermissionsResponse* unsafe_arena_release_role_permissions_response();

  // .iroha.protocol.TransactionsPageResponse transactions_page_response = 11;
  bool has_transactions_page_response() const;
  private:
  bool _internal_has_transactions_page_response() const;
  public:
  void clear_transactions_page_response();
  const ::iroha::protocol::TransactionsPageResponse& transactions_page_response() const;
  ::iroha::protocol::TransactionsPageResponse* release_transactions_page_response();
  ::iroha::protocol::TransactionsPageResponse* mutable_transactions_page_response();
  void set_allocated_transactions_page_response(::iroha::protocol::TransactionsPageResponse* transactions_page_response);
  private:
  const ::iroha::protocol::TransactionsPageResponse& _internal_transactions_page_response() const;
  ::iroha::protocol::TransactionsPageResponse* _internal_mutable_transactions_page_response();
  public:
  void unsafe_arena_set_allocated_transactions_page_response(
      ::iroha::protocol::TransactionsPageResponse* transactions_page_response);
  ::iroha::protocol::TransactionsPageResponse* unsafe_arena_release_transactions_page_response();

  // .iroha.protocol.PendingTransactionsPageResponse pending_transactions_page_response = 13;
  bool has_pending_transactions_page_response() const;
  private:
  bool _internal_has_pending_transactions_page_response() const;
  public:
  void clear_pending_transactions_page_response();
  const ::iroha::protocol::PendingTransactionsPageResponse& pending_transactions_page_response() const;
  ::iroha::protocol::PendingTransactionsPageResponse* release_pending_transactions_page_response();
  ::iroha::protocol::PendingTransactionsPageResponse* mutable_pending_transactions_page_response();
  void set_allocated_pending_transactions_page_response(::iroha::protocol::PendingTransactionsPageResponse* pending_transactions_page_response);
  private:
  const ::iroha::protocol::PendingTransactionsPageResponse& _internal_pending_transactions_page_response() const;
  ::iroha::protocol::PendingTransactionsPageResponse* _internal_mutable_pending_transactions_page_response();
  public:
  void unsafe_arena_set_allocated_pending_transactions_page_response(
      ::iroha::protocol::PendingTransactionsPageResponse* pending_transactions_page_response);
  ::iroha::protocol::PendingTransactionsPageResponse* unsafe_arena_release_pending_transactions_page_response();

  // .iroha.protocol.BlockResponse block_response = 12;
  bool has_block_response() const;
  private:
  bool _internal_has_block_response() const;
  public:
  void clear_block_response();
  const ::iroha::protocol::BlockResponse& block_response() const;
  ::iroha::protocol::BlockResponse* release_block_response();
  ::iroha::protocol::BlockResponse* mutable_block_response();
  void set_allocated_block_response(::iroha::protocol::BlockResponse* block_response);
  private:
  const ::iroha::protocol::BlockResponse& _internal_block_response() const;
  ::iroha::protocol::BlockResponse* _internal_mutable_block_response();
  public:
  void unsafe_arena_set_allocated_block_response(
      ::iroha::protocol::BlockResponse* block_response);
  ::iroha::protocol::BlockResponse* unsafe_arena_release_block_response();

  // .iroha.protocol.PeersResponse peers_response = 14;
  bool has_peers_response() const;
  private:
  bool _internal_has_peers_response() const;
  public:
  void clear_peers_response();
  const ::iroha::protocol::PeersResponse& peers_response() const;
  ::iroha::protocol::PeersResponse* release_peers_response();
  ::iroha::protocol::PeersResponse* mutable_peers_response();
  void set_allocated_peers_response(::iroha::protocol::PeersResponse* peers_response);
  private:
  const ::iroha::protocol::PeersResponse& _internal_peers_response() const;
  ::iroha::protocol::PeersResponse* _internal_mutable_peers_response();
  public:
  void unsafe_arena_set_allocated_peers_response(
      ::iroha::protocol::PeersResponse* peers_response);
  ::iroha::protocol::PeersResponse* unsafe_arena_release_peers_response();

  // .iroha.protocol.EngineReceiptsResponse engine_receipts_response = 15;
  bool has_engine_receipts_response() const;
  private:
  bool _internal_has_engine_receipts_response() const;
  public:
  void clear_engine_receipts_response();
  const ::iroha::protocol::EngineReceiptsResponse& engine_receipts_response() const;
  ::iroha::protocol::EngineReceiptsResponse* release_engine_receipts_response();
  ::iroha::protocol::EngineReceiptsResponse* mutable_engine_receipts_response();
  void set_allocated_engine_receipts_response(::iroha::protocol::EngineReceiptsResponse* engine_receipts_response);
  private:
  const ::iroha::protocol::EngineReceiptsResponse& _internal_engine_receipts_response() const;
  ::iroha::protocol::EngineReceiptsResponse* _internal_mutable_engine_receipts_response();
  public:
  void unsafe_arena_set_allocated_engine_receipts_response(
      ::iroha::protocol::EngineReceiptsResponse* engine_receipts_response);
  ::iroha::protocol::EngineReceiptsResponse* unsafe_arena_release_engine_receipts_response();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.QueryResponse)
 private:
  class _Internal;
  void set_has_account_assets_response();
  void set_has_account_detail_response();
  void set_has_account_response();
  void set_has_error_response();
  void set_has_signatories_response();
  void set_has_transactions_response();
  void set_has_asset_response();
  void set_has_roles_response();
  void set_has_role_permissions_response();
  void set_has_transactions_page_response();
  void set_has_pending_transactions_page_response();
  void set_has_block_response();
  void set_has_peers_response();
  void set_has_engine_receipts_response();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_hash_;
  union ResponseUnion {
    constexpr ResponseUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::iroha::protocol::AccountAssetResponse* account_assets_response_;
    ::iroha::protocol::AccountDetailResponse* account_detail_response_;
    ::iroha::protocol::AccountResponse* account_response_;
    ::iroha::protocol::ErrorResponse* error_response_;
    ::iroha::protocol::SignatoriesResponse* signatories_response_;
    ::iroha::protocol::TransactionsResponse* transactions_response_;
    ::iroha::protocol::AssetResponse* asset_response_;
    ::iroha::protocol::RolesResponse* roles_response_;
    ::iroha::protocol::RolePermissionsResponse* role_permissions_response_;
    ::iroha::protocol::TransactionsPageResponse* transactions_page_response_;
    ::iroha::protocol::PendingTransactionsPageResponse* pending_transactions_page_response_;
    ::iroha::protocol::BlockResponse* block_response_;
    ::iroha::protocol::PeersResponse* peers_response_;
    ::iroha::protocol::EngineReceiptsResponse* engine_receipts_response_;
  } response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class BlockResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.BlockResponse) */ {
 public:
  inline BlockResponse() : BlockResponse(nullptr) {}
  virtual ~BlockResponse();
  explicit constexpr BlockResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockResponse(const BlockResponse& from);
  BlockResponse(BlockResponse&& from) noexcept
    : BlockResponse() {
    *this = ::std::move(from);
  }

  inline BlockResponse& operator=(const BlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockResponse& operator=(BlockResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockResponse* internal_default_instance() {
    return reinterpret_cast<const BlockResponse*>(
               &_BlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BlockResponse& a, BlockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockResponse* New() const final {
    return CreateMaybeMessage<BlockResponse>(nullptr);
  }

  BlockResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockResponse& from);
  void MergeFrom(const BlockResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.BlockResponse";
  }
  protected:
  explicit BlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // .iroha.protocol.Block block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::iroha::protocol::Block& block() const;
  ::iroha::protocol::Block* release_block();
  ::iroha::protocol::Block* mutable_block();
  void set_allocated_block(::iroha::protocol::Block* block);
  private:
  const ::iroha::protocol::Block& _internal_block() const;
  ::iroha::protocol::Block* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::iroha::protocol::Block* block);
  ::iroha::protocol::Block* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:iroha.protocol.BlockResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::iroha::protocol::Block* block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class BlockErrorResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.BlockErrorResponse) */ {
 public:
  inline BlockErrorResponse() : BlockErrorResponse(nullptr) {}
  virtual ~BlockErrorResponse();
  explicit constexpr BlockErrorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockErrorResponse(const BlockErrorResponse& from);
  BlockErrorResponse(BlockErrorResponse&& from) noexcept
    : BlockErrorResponse() {
    *this = ::std::move(from);
  }

  inline BlockErrorResponse& operator=(const BlockErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockErrorResponse& operator=(BlockErrorResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockErrorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockErrorResponse* internal_default_instance() {
    return reinterpret_cast<const BlockErrorResponse*>(
               &_BlockErrorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BlockErrorResponse& a, BlockErrorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockErrorResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockErrorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockErrorResponse* New() const final {
    return CreateMaybeMessage<BlockErrorResponse>(nullptr);
  }

  BlockErrorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockErrorResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockErrorResponse& from);
  void MergeFrom(const BlockErrorResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockErrorResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.BlockErrorResponse";
  }
  protected:
  explicit BlockErrorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:iroha.protocol.BlockErrorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class BlockQueryResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.BlockQueryResponse) */ {
 public:
  inline BlockQueryResponse() : BlockQueryResponse(nullptr) {}
  virtual ~BlockQueryResponse();
  explicit constexpr BlockQueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockQueryResponse(const BlockQueryResponse& from);
  BlockQueryResponse(BlockQueryResponse&& from) noexcept
    : BlockQueryResponse() {
    *this = ::std::move(from);
  }

  inline BlockQueryResponse& operator=(const BlockQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockQueryResponse& operator=(BlockQueryResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockQueryResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kBlockResponse = 1,
    kBlockErrorResponse = 2,
    RESPONSE_NOT_SET = 0,
  };

  static inline const BlockQueryResponse* internal_default_instance() {
    return reinterpret_cast<const BlockQueryResponse*>(
               &_BlockQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(BlockQueryResponse& a, BlockQueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockQueryResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockQueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockQueryResponse* New() const final {
    return CreateMaybeMessage<BlockQueryResponse>(nullptr);
  }

  BlockQueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockQueryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockQueryResponse& from);
  void MergeFrom(const BlockQueryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockQueryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.BlockQueryResponse";
  }
  protected:
  explicit BlockQueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockResponseFieldNumber = 1,
    kBlockErrorResponseFieldNumber = 2,
  };
  // .iroha.protocol.BlockResponse block_response = 1;
  bool has_block_response() const;
  private:
  bool _internal_has_block_response() const;
  public:
  void clear_block_response();
  const ::iroha::protocol::BlockResponse& block_response() const;
  ::iroha::protocol::BlockResponse* release_block_response();
  ::iroha::protocol::BlockResponse* mutable_block_response();
  void set_allocated_block_response(::iroha::protocol::BlockResponse* block_response);
  private:
  const ::iroha::protocol::BlockResponse& _internal_block_response() const;
  ::iroha::protocol::BlockResponse* _internal_mutable_block_response();
  public:
  void unsafe_arena_set_allocated_block_response(
      ::iroha::protocol::BlockResponse* block_response);
  ::iroha::protocol::BlockResponse* unsafe_arena_release_block_response();

  // .iroha.protocol.BlockErrorResponse block_error_response = 2;
  bool has_block_error_response() const;
  private:
  bool _internal_has_block_error_response() const;
  public:
  void clear_block_error_response();
  const ::iroha::protocol::BlockErrorResponse& block_error_response() const;
  ::iroha::protocol::BlockErrorResponse* release_block_error_response();
  ::iroha::protocol::BlockErrorResponse* mutable_block_error_response();
  void set_allocated_block_error_response(::iroha::protocol::BlockErrorResponse* block_error_response);
  private:
  const ::iroha::protocol::BlockErrorResponse& _internal_block_error_response() const;
  ::iroha::protocol::BlockErrorResponse* _internal_mutable_block_error_response();
  public:
  void unsafe_arena_set_allocated_block_error_response(
      ::iroha::protocol::BlockErrorResponse* block_error_response);
  ::iroha::protocol::BlockErrorResponse* unsafe_arena_release_block_error_response();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.BlockQueryResponse)
 private:
  class _Internal;
  void set_has_block_response();
  void set_has_block_error_response();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResponseUnion {
    constexpr ResponseUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::iroha::protocol::BlockResponse* block_response_;
    ::iroha::protocol::BlockErrorResponse* block_error_response_;
  } response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// -------------------------------------------------------------------

class HealthcheckData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iroha.protocol.HealthcheckData) */ {
 public:
  inline HealthcheckData() : HealthcheckData(nullptr) {}
  virtual ~HealthcheckData();
  explicit constexpr HealthcheckData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthcheckData(const HealthcheckData& from);
  HealthcheckData(HealthcheckData&& from) noexcept
    : HealthcheckData() {
    *this = ::std::move(from);
  }

  inline HealthcheckData& operator=(const HealthcheckData& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthcheckData& operator=(HealthcheckData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HealthcheckData& default_instance() {
    return *internal_default_instance();
  }
  enum OptMemoryConsumptionCase {
    kMemoryConsumption = 1,
    OPT_MEMORY_CONSUMPTION_NOT_SET = 0,
  };

  enum OptIsHealthyCase {
    kIsHealthy = 2,
    OPT_IS_HEALTHY_NOT_SET = 0,
  };

  enum OptIsSyncingCase {
    kIsSyncing = 3,
    OPT_IS_SYNCING_NOT_SET = 0,
  };

  enum OptLastBlockHeightCase {
    kLastBlockHeight = 4,
    OPT_LAST_BLOCK_HEIGHT_NOT_SET = 0,
  };

  enum OptLastBlockRejectCase {
    kLastBlockReject = 5,
    OPT_LAST_BLOCK_REJECT_NOT_SET = 0,
  };

  static inline const HealthcheckData* internal_default_instance() {
    return reinterpret_cast<const HealthcheckData*>(
               &_HealthcheckData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(HealthcheckData& a, HealthcheckData& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthcheckData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthcheckData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HealthcheckData* New() const final {
    return CreateMaybeMessage<HealthcheckData>(nullptr);
  }

  HealthcheckData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HealthcheckData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HealthcheckData& from);
  void MergeFrom(const HealthcheckData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthcheckData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iroha.protocol.HealthcheckData";
  }
  protected:
  explicit HealthcheckData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_qry_5fresponses_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoryConsumptionFieldNumber = 1,
    kIsHealthyFieldNumber = 2,
    kIsSyncingFieldNumber = 3,
    kLastBlockHeightFieldNumber = 4,
    kLastBlockRejectFieldNumber = 5,
  };
  // uint64 memory_consumption = 1;
  bool has_memory_consumption() const;
  private:
  bool _internal_has_memory_consumption() const;
  public:
  void clear_memory_consumption();
  ::PROTOBUF_NAMESPACE_ID::uint64 memory_consumption() const;
  void set_memory_consumption(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_memory_consumption() const;
  void _internal_set_memory_consumption(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool is_healthy = 2;
  bool has_is_healthy() const;
  private:
  bool _internal_has_is_healthy() const;
  public:
  void clear_is_healthy();
  bool is_healthy() const;
  void set_is_healthy(bool value);
  private:
  bool _internal_is_healthy() const;
  void _internal_set_is_healthy(bool value);
  public:

  // bool is_syncing = 3;
  bool has_is_syncing() const;
  private:
  bool _internal_has_is_syncing() const;
  public:
  void clear_is_syncing();
  bool is_syncing() const;
  void set_is_syncing(bool value);
  private:
  bool _internal_is_syncing() const;
  void _internal_set_is_syncing(bool value);
  public:

  // uint64 last_block_height = 4;
  bool has_last_block_height() const;
  private:
  bool _internal_has_last_block_height() const;
  public:
  void clear_last_block_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_block_height() const;
  void set_last_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_block_height() const;
  void _internal_set_last_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 last_block_reject = 5;
  bool has_last_block_reject() const;
  private:
  bool _internal_has_last_block_reject() const;
  public:
  void clear_last_block_reject();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_block_reject() const;
  void set_last_block_reject(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_block_reject() const;
  void _internal_set_last_block_reject(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  void clear_opt_memory_consumption();
  OptMemoryConsumptionCase opt_memory_consumption_case() const;
  void clear_opt_is_healthy();
  OptIsHealthyCase opt_is_healthy_case() const;
  void clear_opt_is_syncing();
  OptIsSyncingCase opt_is_syncing_case() const;
  void clear_opt_last_block_height();
  OptLastBlockHeightCase opt_last_block_height_case() const;
  void clear_opt_last_block_reject();
  OptLastBlockRejectCase opt_last_block_reject_case() const;
  // @@protoc_insertion_point(class_scope:iroha.protocol.HealthcheckData)
 private:
  class _Internal;
  void set_has_memory_consumption();
  void set_has_is_healthy();
  void set_has_is_syncing();
  void set_has_last_block_height();
  void set_has_last_block_reject();

  inline bool has_opt_memory_consumption() const;
  inline void clear_has_opt_memory_consumption();

  inline bool has_opt_is_healthy() const;
  inline void clear_has_opt_is_healthy();

  inline bool has_opt_is_syncing() const;
  inline void clear_has_opt_is_syncing();

  inline bool has_opt_last_block_height() const;
  inline void clear_has_opt_last_block_height();

  inline bool has_opt_last_block_reject() const;
  inline void clear_has_opt_last_block_reject();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union OptMemoryConsumptionUnion {
    constexpr OptMemoryConsumptionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint64 memory_consumption_;
  } opt_memory_consumption_;
  union OptIsHealthyUnion {
    constexpr OptIsHealthyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool is_healthy_;
  } opt_is_healthy_;
  union OptIsSyncingUnion {
    constexpr OptIsSyncingUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool is_syncing_;
  } opt_is_syncing_;
  union OptLastBlockHeightUnion {
    constexpr OptLastBlockHeightUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint64 last_block_height_;
  } opt_last_block_height_;
  union OptLastBlockRejectUnion {
    constexpr OptLastBlockRejectUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint64 last_block_reject_;
  } opt_last_block_reject_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[5];

  friend struct ::TableStruct_qry_5fresponses_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Asset

// string asset_id = 1;
inline void Asset::clear_asset_id() {
  asset_id_.ClearToEmpty();
}
inline const std::string& Asset::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Asset.asset_id)
  return _internal_asset_id();
}
inline void Asset::set_asset_id(const std::string& value) {
  _internal_set_asset_id(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Asset.asset_id)
}
inline std::string* Asset::mutable_asset_id() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Asset.asset_id)
  return _internal_mutable_asset_id();
}
inline const std::string& Asset::_internal_asset_id() const {
  return asset_id_.Get();
}
inline void Asset::_internal_set_asset_id(const std::string& value) {
  
  asset_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Asset::set_asset_id(std::string&& value) {
  
  asset_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Asset.asset_id)
}
inline void Asset::set_asset_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  asset_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Asset.asset_id)
}
inline void Asset::set_asset_id(const char* value,
    size_t size) {
  
  asset_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Asset.asset_id)
}
inline std::string* Asset::_internal_mutable_asset_id() {
  
  return asset_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Asset::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Asset.asset_id)
  return asset_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Asset::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  asset_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), asset_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Asset.asset_id)
}

// string domain_id = 2;
inline void Asset::clear_domain_id() {
  domain_id_.ClearToEmpty();
}
inline const std::string& Asset::domain_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Asset.domain_id)
  return _internal_domain_id();
}
inline void Asset::set_domain_id(const std::string& value) {
  _internal_set_domain_id(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Asset.domain_id)
}
inline std::string* Asset::mutable_domain_id() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Asset.domain_id)
  return _internal_mutable_domain_id();
}
inline const std::string& Asset::_internal_domain_id() const {
  return domain_id_.Get();
}
inline void Asset::_internal_set_domain_id(const std::string& value) {
  
  domain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Asset::set_domain_id(std::string&& value) {
  
  domain_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Asset.domain_id)
}
inline void Asset::set_domain_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Asset.domain_id)
}
inline void Asset::set_domain_id(const char* value,
    size_t size) {
  
  domain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Asset.domain_id)
}
inline std::string* Asset::_internal_mutable_domain_id() {
  
  return domain_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Asset::release_domain_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Asset.domain_id)
  return domain_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Asset::set_allocated_domain_id(std::string* domain_id) {
  if (domain_id != nullptr) {
    
  } else {
    
  }
  domain_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Asset.domain_id)
}

// uint32 precision = 3;
inline void Asset::clear_precision() {
  precision_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Asset::_internal_precision() const {
  return precision_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Asset::precision() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Asset.precision)
  return _internal_precision();
}
inline void Asset::_internal_set_precision(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  precision_ = value;
}
inline void Asset::set_precision(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Asset.precision)
}

// -------------------------------------------------------------------

// Domain

// string domain_id = 1;
inline void Domain::clear_domain_id() {
  domain_id_.ClearToEmpty();
}
inline const std::string& Domain::domain_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Domain.domain_id)
  return _internal_domain_id();
}
inline void Domain::set_domain_id(const std::string& value) {
  _internal_set_domain_id(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Domain.domain_id)
}
inline std::string* Domain::mutable_domain_id() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Domain.domain_id)
  return _internal_mutable_domain_id();
}
inline const std::string& Domain::_internal_domain_id() const {
  return domain_id_.Get();
}
inline void Domain::_internal_set_domain_id(const std::string& value) {
  
  domain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Domain::set_domain_id(std::string&& value) {
  
  domain_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Domain.domain_id)
}
inline void Domain::set_domain_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Domain.domain_id)
}
inline void Domain::set_domain_id(const char* value,
    size_t size) {
  
  domain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Domain.domain_id)
}
inline std::string* Domain::_internal_mutable_domain_id() {
  
  return domain_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Domain::release_domain_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Domain.domain_id)
  return domain_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Domain::set_allocated_domain_id(std::string* domain_id) {
  if (domain_id != nullptr) {
    
  } else {
    
  }
  domain_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Domain.domain_id)
}

// string default_role = 2;
inline void Domain::clear_default_role() {
  default_role_.ClearToEmpty();
}
inline const std::string& Domain::default_role() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Domain.default_role)
  return _internal_default_role();
}
inline void Domain::set_default_role(const std::string& value) {
  _internal_set_default_role(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Domain.default_role)
}
inline std::string* Domain::mutable_default_role() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Domain.default_role)
  return _internal_mutable_default_role();
}
inline const std::string& Domain::_internal_default_role() const {
  return default_role_.Get();
}
inline void Domain::_internal_set_default_role(const std::string& value) {
  
  default_role_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Domain::set_default_role(std::string&& value) {
  
  default_role_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Domain.default_role)
}
inline void Domain::set_default_role(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  default_role_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Domain.default_role)
}
inline void Domain::set_default_role(const char* value,
    size_t size) {
  
  default_role_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Domain.default_role)
}
inline std::string* Domain::_internal_mutable_default_role() {
  
  return default_role_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Domain::release_default_role() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Domain.default_role)
  return default_role_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Domain::set_allocated_default_role(std::string* default_role) {
  if (default_role != nullptr) {
    
  } else {
    
  }
  default_role_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), default_role,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Domain.default_role)
}

// -------------------------------------------------------------------

// Account

// string account_id = 1;
inline void Account::clear_account_id() {
  account_id_.ClearToEmpty();
}
inline const std::string& Account::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Account.account_id)
  return _internal_account_id();
}
inline void Account::set_account_id(const std::string& value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Account.account_id)
}
inline std::string* Account::mutable_account_id() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Account.account_id)
  return _internal_mutable_account_id();
}
inline const std::string& Account::_internal_account_id() const {
  return account_id_.Get();
}
inline void Account::_internal_set_account_id(const std::string& value) {
  
  account_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Account::set_account_id(std::string&& value) {
  
  account_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Account.account_id)
}
inline void Account::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Account.account_id)
}
inline void Account::set_account_id(const char* value,
    size_t size) {
  
  account_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Account.account_id)
}
inline std::string* Account::_internal_mutable_account_id() {
  
  return account_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Account::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Account.account_id)
  return account_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Account::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  account_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Account.account_id)
}

// string domain_id = 2;
inline void Account::clear_domain_id() {
  domain_id_.ClearToEmpty();
}
inline const std::string& Account::domain_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Account.domain_id)
  return _internal_domain_id();
}
inline void Account::set_domain_id(const std::string& value) {
  _internal_set_domain_id(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Account.domain_id)
}
inline std::string* Account::mutable_domain_id() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Account.domain_id)
  return _internal_mutable_domain_id();
}
inline const std::string& Account::_internal_domain_id() const {
  return domain_id_.Get();
}
inline void Account::_internal_set_domain_id(const std::string& value) {
  
  domain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Account::set_domain_id(std::string&& value) {
  
  domain_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Account.domain_id)
}
inline void Account::set_domain_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Account.domain_id)
}
inline void Account::set_domain_id(const char* value,
    size_t size) {
  
  domain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Account.domain_id)
}
inline std::string* Account::_internal_mutable_domain_id() {
  
  return domain_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Account::release_domain_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Account.domain_id)
  return domain_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Account::set_allocated_domain_id(std::string* domain_id) {
  if (domain_id != nullptr) {
    
  } else {
    
  }
  domain_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Account.domain_id)
}

// uint32 quorum = 3;
inline void Account::clear_quorum() {
  quorum_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Account::_internal_quorum() const {
  return quorum_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Account::quorum() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Account.quorum)
  return _internal_quorum();
}
inline void Account::_internal_set_quorum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  quorum_ = value;
}
inline void Account::set_quorum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_quorum(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Account.quorum)
}

// string json_data = 4;
inline void Account::clear_json_data() {
  json_data_.ClearToEmpty();
}
inline const std::string& Account::json_data() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.Account.json_data)
  return _internal_json_data();
}
inline void Account::set_json_data(const std::string& value) {
  _internal_set_json_data(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.Account.json_data)
}
inline std::string* Account::mutable_json_data() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.Account.json_data)
  return _internal_mutable_json_data();
}
inline const std::string& Account::_internal_json_data() const {
  return json_data_.Get();
}
inline void Account::_internal_set_json_data(const std::string& value) {
  
  json_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Account::set_json_data(std::string&& value) {
  
  json_data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.Account.json_data)
}
inline void Account::set_json_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  json_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.Account.json_data)
}
inline void Account::set_json_data(const char* value,
    size_t size) {
  
  json_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.Account.json_data)
}
inline std::string* Account::_internal_mutable_json_data() {
  
  return json_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Account::release_json_data() {
  // @@protoc_insertion_point(field_release:iroha.protocol.Account.json_data)
  return json_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Account::set_allocated_json_data(std::string* json_data) {
  if (json_data != nullptr) {
    
  } else {
    
  }
  json_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), json_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.Account.json_data)
}

// -------------------------------------------------------------------

// AccountAsset

// string asset_id = 1;
inline void AccountAsset::clear_asset_id() {
  asset_id_.ClearToEmpty();
}
inline const std::string& AccountAsset::asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountAsset.asset_id)
  return _internal_asset_id();
}
inline void AccountAsset::set_asset_id(const std::string& value) {
  _internal_set_asset_id(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountAsset.asset_id)
}
inline std::string* AccountAsset::mutable_asset_id() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountAsset.asset_id)
  return _internal_mutable_asset_id();
}
inline const std::string& AccountAsset::_internal_asset_id() const {
  return asset_id_.Get();
}
inline void AccountAsset::_internal_set_asset_id(const std::string& value) {
  
  asset_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AccountAsset::set_asset_id(std::string&& value) {
  
  asset_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AccountAsset.asset_id)
}
inline void AccountAsset::set_asset_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  asset_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AccountAsset.asset_id)
}
inline void AccountAsset::set_asset_id(const char* value,
    size_t size) {
  
  asset_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AccountAsset.asset_id)
}
inline std::string* AccountAsset::_internal_mutable_asset_id() {
  
  return asset_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AccountAsset::release_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountAsset.asset_id)
  return asset_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AccountAsset::set_allocated_asset_id(std::string* asset_id) {
  if (asset_id != nullptr) {
    
  } else {
    
  }
  asset_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), asset_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountAsset.asset_id)
}

// string account_id = 2;
inline void AccountAsset::clear_account_id() {
  account_id_.ClearToEmpty();
}
inline const std::string& AccountAsset::account_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountAsset.account_id)
  return _internal_account_id();
}
inline void AccountAsset::set_account_id(const std::string& value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountAsset.account_id)
}
inline std::string* AccountAsset::mutable_account_id() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountAsset.account_id)
  return _internal_mutable_account_id();
}
inline const std::string& AccountAsset::_internal_account_id() const {
  return account_id_.Get();
}
inline void AccountAsset::_internal_set_account_id(const std::string& value) {
  
  account_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AccountAsset::set_account_id(std::string&& value) {
  
  account_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AccountAsset.account_id)
}
inline void AccountAsset::set_account_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AccountAsset.account_id)
}
inline void AccountAsset::set_account_id(const char* value,
    size_t size) {
  
  account_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AccountAsset.account_id)
}
inline std::string* AccountAsset::_internal_mutable_account_id() {
  
  return account_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AccountAsset::release_account_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountAsset.account_id)
  return account_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AccountAsset::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  account_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountAsset.account_id)
}

// string balance = 3;
inline void AccountAsset::clear_balance() {
  balance_.ClearToEmpty();
}
inline const std::string& AccountAsset::balance() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountAsset.balance)
  return _internal_balance();
}
inline void AccountAsset::set_balance(const std::string& value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountAsset.balance)
}
inline std::string* AccountAsset::mutable_balance() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountAsset.balance)
  return _internal_mutable_balance();
}
inline const std::string& AccountAsset::_internal_balance() const {
  return balance_.Get();
}
inline void AccountAsset::_internal_set_balance(const std::string& value) {
  
  balance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AccountAsset::set_balance(std::string&& value) {
  
  balance_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AccountAsset.balance)
}
inline void AccountAsset::set_balance(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  balance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AccountAsset.balance)
}
inline void AccountAsset::set_balance(const char* value,
    size_t size) {
  
  balance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AccountAsset.balance)
}
inline std::string* AccountAsset::_internal_mutable_balance() {
  
  return balance_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AccountAsset::release_balance() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountAsset.balance)
  return balance_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AccountAsset::set_allocated_balance(std::string* balance) {
  if (balance != nullptr) {
    
  } else {
    
  }
  balance_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), balance,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountAsset.balance)
}

// -------------------------------------------------------------------

// AccountAssetResponse

// repeated .iroha.protocol.AccountAsset account_assets = 1;
inline int AccountAssetResponse::_internal_account_assets_size() const {
  return account_assets_.size();
}
inline int AccountAssetResponse::account_assets_size() const {
  return _internal_account_assets_size();
}
inline void AccountAssetResponse::clear_account_assets() {
  account_assets_.Clear();
}
inline ::iroha::protocol::AccountAsset* AccountAssetResponse::mutable_account_assets(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountAssetResponse.account_assets)
  return account_assets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::AccountAsset >*
AccountAssetResponse::mutable_account_assets() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.AccountAssetResponse.account_assets)
  return &account_assets_;
}
inline const ::iroha::protocol::AccountAsset& AccountAssetResponse::_internal_account_assets(int index) const {
  return account_assets_.Get(index);
}
inline const ::iroha::protocol::AccountAsset& AccountAssetResponse::account_assets(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountAssetResponse.account_assets)
  return _internal_account_assets(index);
}
inline ::iroha::protocol::AccountAsset* AccountAssetResponse::_internal_add_account_assets() {
  return account_assets_.Add();
}
inline ::iroha::protocol::AccountAsset* AccountAssetResponse::add_account_assets() {
  // @@protoc_insertion_point(field_add:iroha.protocol.AccountAssetResponse.account_assets)
  return _internal_add_account_assets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::AccountAsset >&
AccountAssetResponse::account_assets() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.AccountAssetResponse.account_assets)
  return account_assets_;
}

// uint32 total_number = 2;
inline void AccountAssetResponse::clear_total_number() {
  total_number_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountAssetResponse::_internal_total_number() const {
  return total_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountAssetResponse::total_number() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountAssetResponse.total_number)
  return _internal_total_number();
}
inline void AccountAssetResponse::_internal_set_total_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  total_number_ = value;
}
inline void AccountAssetResponse::set_total_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_total_number(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountAssetResponse.total_number)
}

// string next_asset_id = 3;
inline bool AccountAssetResponse::_internal_has_next_asset_id() const {
  return opt_next_asset_id_case() == kNextAssetId;
}
inline bool AccountAssetResponse::has_next_asset_id() const {
  return _internal_has_next_asset_id();
}
inline void AccountAssetResponse::set_has_next_asset_id() {
  _oneof_case_[0] = kNextAssetId;
}
inline void AccountAssetResponse::clear_next_asset_id() {
  if (_internal_has_next_asset_id()) {
    opt_next_asset_id_.next_asset_id_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_opt_next_asset_id();
  }
}
inline const std::string& AccountAssetResponse::next_asset_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountAssetResponse.next_asset_id)
  return _internal_next_asset_id();
}
inline void AccountAssetResponse::set_next_asset_id(const std::string& value) {
  _internal_set_next_asset_id(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountAssetResponse.next_asset_id)
}
inline std::string* AccountAssetResponse::mutable_next_asset_id() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountAssetResponse.next_asset_id)
  return _internal_mutable_next_asset_id();
}
inline const std::string& AccountAssetResponse::_internal_next_asset_id() const {
  if (_internal_has_next_asset_id()) {
    return opt_next_asset_id_.next_asset_id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AccountAssetResponse::_internal_set_next_asset_id(const std::string& value) {
  if (!_internal_has_next_asset_id()) {
    clear_opt_next_asset_id();
    set_has_next_asset_id();
    opt_next_asset_id_.next_asset_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  opt_next_asset_id_.next_asset_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AccountAssetResponse::set_next_asset_id(std::string&& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountAssetResponse.next_asset_id)
  if (!_internal_has_next_asset_id()) {
    clear_opt_next_asset_id();
    set_has_next_asset_id();
    opt_next_asset_id_.next_asset_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  opt_next_asset_id_.next_asset_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AccountAssetResponse.next_asset_id)
}
inline void AccountAssetResponse::set_next_asset_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_next_asset_id()) {
    clear_opt_next_asset_id();
    set_has_next_asset_id();
    opt_next_asset_id_.next_asset_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  opt_next_asset_id_.next_asset_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AccountAssetResponse.next_asset_id)
}
inline void AccountAssetResponse::set_next_asset_id(const char* value,
                             size_t size) {
  if (!_internal_has_next_asset_id()) {
    clear_opt_next_asset_id();
    set_has_next_asset_id();
    opt_next_asset_id_.next_asset_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  opt_next_asset_id_.next_asset_id_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AccountAssetResponse.next_asset_id)
}
inline std::string* AccountAssetResponse::_internal_mutable_next_asset_id() {
  if (!_internal_has_next_asset_id()) {
    clear_opt_next_asset_id();
    set_has_next_asset_id();
    opt_next_asset_id_.next_asset_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return opt_next_asset_id_.next_asset_id_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AccountAssetResponse::release_next_asset_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountAssetResponse.next_asset_id)
  if (_internal_has_next_asset_id()) {
    clear_has_opt_next_asset_id();
    return opt_next_asset_id_.next_asset_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void AccountAssetResponse::set_allocated_next_asset_id(std::string* next_asset_id) {
  if (has_opt_next_asset_id()) {
    clear_opt_next_asset_id();
  }
  if (next_asset_id != nullptr) {
    set_has_next_asset_id();
    opt_next_asset_id_.next_asset_id_.UnsafeSetDefault(next_asset_id);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(next_asset_id);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountAssetResponse.next_asset_id)
}

inline bool AccountAssetResponse::has_opt_next_asset_id() const {
  return opt_next_asset_id_case() != OPT_NEXT_ASSET_ID_NOT_SET;
}
inline void AccountAssetResponse::clear_has_opt_next_asset_id() {
  _oneof_case_[0] = OPT_NEXT_ASSET_ID_NOT_SET;
}
inline AccountAssetResponse::OptNextAssetIdCase AccountAssetResponse::opt_next_asset_id_case() const {
  return AccountAssetResponse::OptNextAssetIdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AccountDetailResponse

// string detail = 1;
inline void AccountDetailResponse::clear_detail() {
  detail_.ClearToEmpty();
}
inline const std::string& AccountDetailResponse::detail() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountDetailResponse.detail)
  return _internal_detail();
}
inline void AccountDetailResponse::set_detail(const std::string& value) {
  _internal_set_detail(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountDetailResponse.detail)
}
inline std::string* AccountDetailResponse::mutable_detail() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountDetailResponse.detail)
  return _internal_mutable_detail();
}
inline const std::string& AccountDetailResponse::_internal_detail() const {
  return detail_.Get();
}
inline void AccountDetailResponse::_internal_set_detail(const std::string& value) {
  
  detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AccountDetailResponse::set_detail(std::string&& value) {
  
  detail_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.AccountDetailResponse.detail)
}
inline void AccountDetailResponse::set_detail(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AccountDetailResponse.detail)
}
inline void AccountDetailResponse::set_detail(const char* value,
    size_t size) {
  
  detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AccountDetailResponse.detail)
}
inline std::string* AccountDetailResponse::_internal_mutable_detail() {
  
  return detail_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AccountDetailResponse::release_detail() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountDetailResponse.detail)
  return detail_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AccountDetailResponse::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  detail_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), detail,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountDetailResponse.detail)
}

// uint64 total_number = 2;
inline void AccountDetailResponse::clear_total_number() {
  total_number_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AccountDetailResponse::_internal_total_number() const {
  return total_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AccountDetailResponse::total_number() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountDetailResponse.total_number)
  return _internal_total_number();
}
inline void AccountDetailResponse::_internal_set_total_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  total_number_ = value;
}
inline void AccountDetailResponse::set_total_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_total_number(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountDetailResponse.total_number)
}

// .iroha.protocol.AccountDetailRecordId next_record_id = 3;
inline bool AccountDetailResponse::_internal_has_next_record_id() const {
  return this != internal_default_instance() && next_record_id_ != nullptr;
}
inline bool AccountDetailResponse::has_next_record_id() const {
  return _internal_has_next_record_id();
}
inline const ::iroha::protocol::AccountDetailRecordId& AccountDetailResponse::_internal_next_record_id() const {
  const ::iroha::protocol::AccountDetailRecordId* p = next_record_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::AccountDetailRecordId&>(
      ::iroha::protocol::_AccountDetailRecordId_default_instance_);
}
inline const ::iroha::protocol::AccountDetailRecordId& AccountDetailResponse::next_record_id() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountDetailResponse.next_record_id)
  return _internal_next_record_id();
}
inline void AccountDetailResponse::unsafe_arena_set_allocated_next_record_id(
    ::iroha::protocol::AccountDetailRecordId* next_record_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(next_record_id_);
  }
  next_record_id_ = next_record_id;
  if (next_record_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.AccountDetailResponse.next_record_id)
}
inline ::iroha::protocol::AccountDetailRecordId* AccountDetailResponse::release_next_record_id() {
  
  ::iroha::protocol::AccountDetailRecordId* temp = next_record_id_;
  next_record_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::iroha::protocol::AccountDetailRecordId* AccountDetailResponse::unsafe_arena_release_next_record_id() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountDetailResponse.next_record_id)
  
  ::iroha::protocol::AccountDetailRecordId* temp = next_record_id_;
  next_record_id_ = nullptr;
  return temp;
}
inline ::iroha::protocol::AccountDetailRecordId* AccountDetailResponse::_internal_mutable_next_record_id() {
  
  if (next_record_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::AccountDetailRecordId>(GetArena());
    next_record_id_ = p;
  }
  return next_record_id_;
}
inline ::iroha::protocol::AccountDetailRecordId* AccountDetailResponse::mutable_next_record_id() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountDetailResponse.next_record_id)
  return _internal_mutable_next_record_id();
}
inline void AccountDetailResponse::set_allocated_next_record_id(::iroha::protocol::AccountDetailRecordId* next_record_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(next_record_id_);
  }
  if (next_record_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(next_record_id)->GetArena();
    if (message_arena != submessage_arena) {
      next_record_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_record_id, submessage_arena);
    }
    
  } else {
    
  }
  next_record_id_ = next_record_id;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountDetailResponse.next_record_id)
}

// -------------------------------------------------------------------

// AccountResponse

// .iroha.protocol.Account account = 1;
inline bool AccountResponse::_internal_has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline bool AccountResponse::has_account() const {
  return _internal_has_account();
}
inline void AccountResponse::clear_account() {
  if (GetArena() == nullptr && account_ != nullptr) {
    delete account_;
  }
  account_ = nullptr;
}
inline const ::iroha::protocol::Account& AccountResponse::_internal_account() const {
  const ::iroha::protocol::Account* p = account_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::Account&>(
      ::iroha::protocol::_Account_default_instance_);
}
inline const ::iroha::protocol::Account& AccountResponse::account() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountResponse.account)
  return _internal_account();
}
inline void AccountResponse::unsafe_arena_set_allocated_account(
    ::iroha::protocol::Account* account) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.AccountResponse.account)
}
inline ::iroha::protocol::Account* AccountResponse::release_account() {
  
  ::iroha::protocol::Account* temp = account_;
  account_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::iroha::protocol::Account* AccountResponse::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AccountResponse.account)
  
  ::iroha::protocol::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::iroha::protocol::Account* AccountResponse::_internal_mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::Account>(GetArena());
    account_ = p;
  }
  return account_;
}
inline ::iroha::protocol::Account* AccountResponse::mutable_account() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountResponse.account)
  return _internal_mutable_account();
}
inline void AccountResponse::set_allocated_account(::iroha::protocol::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete account_;
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(account);
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AccountResponse.account)
}

// repeated string account_roles = 2;
inline int AccountResponse::_internal_account_roles_size() const {
  return account_roles_.size();
}
inline int AccountResponse::account_roles_size() const {
  return _internal_account_roles_size();
}
inline void AccountResponse::clear_account_roles() {
  account_roles_.Clear();
}
inline std::string* AccountResponse::add_account_roles() {
  // @@protoc_insertion_point(field_add_mutable:iroha.protocol.AccountResponse.account_roles)
  return _internal_add_account_roles();
}
inline const std::string& AccountResponse::_internal_account_roles(int index) const {
  return account_roles_.Get(index);
}
inline const std::string& AccountResponse::account_roles(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AccountResponse.account_roles)
  return _internal_account_roles(index);
}
inline std::string* AccountResponse::mutable_account_roles(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AccountResponse.account_roles)
  return account_roles_.Mutable(index);
}
inline void AccountResponse::set_account_roles(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountResponse.account_roles)
  account_roles_.Mutable(index)->assign(value);
}
inline void AccountResponse::set_account_roles(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.AccountResponse.account_roles)
  account_roles_.Mutable(index)->assign(std::move(value));
}
inline void AccountResponse::set_account_roles(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  account_roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:iroha.protocol.AccountResponse.account_roles)
}
inline void AccountResponse::set_account_roles(int index, const char* value, size_t size) {
  account_roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.AccountResponse.account_roles)
}
inline std::string* AccountResponse::_internal_add_account_roles() {
  return account_roles_.Add();
}
inline void AccountResponse::add_account_roles(const std::string& value) {
  account_roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:iroha.protocol.AccountResponse.account_roles)
}
inline void AccountResponse::add_account_roles(std::string&& value) {
  account_roles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:iroha.protocol.AccountResponse.account_roles)
}
inline void AccountResponse::add_account_roles(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  account_roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:iroha.protocol.AccountResponse.account_roles)
}
inline void AccountResponse::add_account_roles(const char* value, size_t size) {
  account_roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:iroha.protocol.AccountResponse.account_roles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AccountResponse::account_roles() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.AccountResponse.account_roles)
  return account_roles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AccountResponse::mutable_account_roles() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.AccountResponse.account_roles)
  return &account_roles_;
}

// -------------------------------------------------------------------

// AssetResponse

// .iroha.protocol.Asset asset = 1;
inline bool AssetResponse::_internal_has_asset() const {
  return this != internal_default_instance() && asset_ != nullptr;
}
inline bool AssetResponse::has_asset() const {
  return _internal_has_asset();
}
inline void AssetResponse::clear_asset() {
  if (GetArena() == nullptr && asset_ != nullptr) {
    delete asset_;
  }
  asset_ = nullptr;
}
inline const ::iroha::protocol::Asset& AssetResponse::_internal_asset() const {
  const ::iroha::protocol::Asset* p = asset_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::Asset&>(
      ::iroha::protocol::_Asset_default_instance_);
}
inline const ::iroha::protocol::Asset& AssetResponse::asset() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.AssetResponse.asset)
  return _internal_asset();
}
inline void AssetResponse::unsafe_arena_set_allocated_asset(
    ::iroha::protocol::Asset* asset) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(asset_);
  }
  asset_ = asset;
  if (asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.AssetResponse.asset)
}
inline ::iroha::protocol::Asset* AssetResponse::release_asset() {
  
  ::iroha::protocol::Asset* temp = asset_;
  asset_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::iroha::protocol::Asset* AssetResponse::unsafe_arena_release_asset() {
  // @@protoc_insertion_point(field_release:iroha.protocol.AssetResponse.asset)
  
  ::iroha::protocol::Asset* temp = asset_;
  asset_ = nullptr;
  return temp;
}
inline ::iroha::protocol::Asset* AssetResponse::_internal_mutable_asset() {
  
  if (asset_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::Asset>(GetArena());
    asset_ = p;
  }
  return asset_;
}
inline ::iroha::protocol::Asset* AssetResponse::mutable_asset() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.AssetResponse.asset)
  return _internal_mutable_asset();
}
inline void AssetResponse::set_allocated_asset(::iroha::protocol::Asset* asset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete asset_;
  }
  if (asset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(asset);
    if (message_arena != submessage_arena) {
      asset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asset, submessage_arena);
    }
    
  } else {
    
  }
  asset_ = asset;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.AssetResponse.asset)
}

// -------------------------------------------------------------------

// RolesResponse

// repeated string roles = 1;
inline int RolesResponse::_internal_roles_size() const {
  return roles_.size();
}
inline int RolesResponse::roles_size() const {
  return _internal_roles_size();
}
inline void RolesResponse::clear_roles() {
  roles_.Clear();
}
inline std::string* RolesResponse::add_roles() {
  // @@protoc_insertion_point(field_add_mutable:iroha.protocol.RolesResponse.roles)
  return _internal_add_roles();
}
inline const std::string& RolesResponse::_internal_roles(int index) const {
  return roles_.Get(index);
}
inline const std::string& RolesResponse::roles(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RolesResponse.roles)
  return _internal_roles(index);
}
inline std::string* RolesResponse::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.RolesResponse.roles)
  return roles_.Mutable(index);
}
inline void RolesResponse::set_roles(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.RolesResponse.roles)
  roles_.Mutable(index)->assign(value);
}
inline void RolesResponse::set_roles(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.RolesResponse.roles)
  roles_.Mutable(index)->assign(std::move(value));
}
inline void RolesResponse::set_roles(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:iroha.protocol.RolesResponse.roles)
}
inline void RolesResponse::set_roles(int index, const char* value, size_t size) {
  roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.RolesResponse.roles)
}
inline std::string* RolesResponse::_internal_add_roles() {
  return roles_.Add();
}
inline void RolesResponse::add_roles(const std::string& value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:iroha.protocol.RolesResponse.roles)
}
inline void RolesResponse::add_roles(std::string&& value) {
  roles_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:iroha.protocol.RolesResponse.roles)
}
inline void RolesResponse::add_roles(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:iroha.protocol.RolesResponse.roles)
}
inline void RolesResponse::add_roles(const char* value, size_t size) {
  roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:iroha.protocol.RolesResponse.roles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RolesResponse::roles() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.RolesResponse.roles)
  return roles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RolesResponse::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.RolesResponse.roles)
  return &roles_;
}

// -------------------------------------------------------------------

// RolePermissionsResponse

// repeated .iroha.protocol.RolePermission permissions = 1;
inline int RolePermissionsResponse::_internal_permissions_size() const {
  return permissions_.size();
}
inline int RolePermissionsResponse::permissions_size() const {
  return _internal_permissions_size();
}
inline void RolePermissionsResponse::clear_permissions() {
  permissions_.Clear();
}
inline ::iroha::protocol::RolePermission RolePermissionsResponse::_internal_permissions(int index) const {
  return static_cast< ::iroha::protocol::RolePermission >(permissions_.Get(index));
}
inline ::iroha::protocol::RolePermission RolePermissionsResponse::permissions(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.RolePermissionsResponse.permissions)
  return _internal_permissions(index);
}
inline void RolePermissionsResponse::set_permissions(int index, ::iroha::protocol::RolePermission value) {
  permissions_.Set(index, value);
  // @@protoc_insertion_point(field_set:iroha.protocol.RolePermissionsResponse.permissions)
}
inline void RolePermissionsResponse::_internal_add_permissions(::iroha::protocol::RolePermission value) {
  permissions_.Add(value);
}
inline void RolePermissionsResponse::add_permissions(::iroha::protocol::RolePermission value) {
  // @@protoc_insertion_point(field_add:iroha.protocol.RolePermissionsResponse.permissions)
  _internal_add_permissions(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
RolePermissionsResponse::permissions() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.RolePermissionsResponse.permissions)
  return permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
RolePermissionsResponse::_internal_mutable_permissions() {
  return &permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
RolePermissionsResponse::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.RolePermissionsResponse.permissions)
  return _internal_mutable_permissions();
}

// -------------------------------------------------------------------

// ErrorResponse

// .iroha.protocol.ErrorResponse.Reason reason = 1;
inline void ErrorResponse::clear_reason() {
  reason_ = 0;
}
inline ::iroha::protocol::ErrorResponse_Reason ErrorResponse::_internal_reason() const {
  return static_cast< ::iroha::protocol::ErrorResponse_Reason >(reason_);
}
inline ::iroha::protocol::ErrorResponse_Reason ErrorResponse::reason() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.ErrorResponse.reason)
  return _internal_reason();
}
inline void ErrorResponse::_internal_set_reason(::iroha::protocol::ErrorResponse_Reason value) {
  
  reason_ = value;
}
inline void ErrorResponse::set_reason(::iroha::protocol::ErrorResponse_Reason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.ErrorResponse.reason)
}

// string message = 2;
inline void ErrorResponse::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& ErrorResponse::message() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.ErrorResponse.message)
  return _internal_message();
}
inline void ErrorResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.ErrorResponse.message)
}
inline std::string* ErrorResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.ErrorResponse.message)
  return _internal_mutable_message();
}
inline const std::string& ErrorResponse::_internal_message() const {
  return message_.Get();
}
inline void ErrorResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ErrorResponse::set_message(std::string&& value) {
  
  message_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.ErrorResponse.message)
}
inline void ErrorResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.ErrorResponse.message)
}
inline void ErrorResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.ErrorResponse.message)
}
inline std::string* ErrorResponse::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ErrorResponse::release_message() {
  // @@protoc_insertion_point(field_release:iroha.protocol.ErrorResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErrorResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.ErrorResponse.message)
}

// uint32 error_code = 3;
inline void ErrorResponse::clear_error_code() {
  error_code_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ErrorResponse::_internal_error_code() const {
  return error_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ErrorResponse::error_code() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.ErrorResponse.error_code)
  return _internal_error_code();
}
inline void ErrorResponse::_internal_set_error_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  error_code_ = value;
}
inline void ErrorResponse::set_error_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.ErrorResponse.error_code)
}

// -------------------------------------------------------------------

// SignatoriesResponse

// repeated string keys = 1;
inline int SignatoriesResponse::_internal_keys_size() const {
  return keys_.size();
}
inline int SignatoriesResponse::keys_size() const {
  return _internal_keys_size();
}
inline void SignatoriesResponse::clear_keys() {
  keys_.Clear();
}
inline std::string* SignatoriesResponse::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:iroha.protocol.SignatoriesResponse.keys)
  return _internal_add_keys();
}
inline const std::string& SignatoriesResponse::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& SignatoriesResponse::keys(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.SignatoriesResponse.keys)
  return _internal_keys(index);
}
inline std::string* SignatoriesResponse::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.SignatoriesResponse.keys)
  return keys_.Mutable(index);
}
inline void SignatoriesResponse::set_keys(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.SignatoriesResponse.keys)
  keys_.Mutable(index)->assign(value);
}
inline void SignatoriesResponse::set_keys(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.SignatoriesResponse.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
inline void SignatoriesResponse::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:iroha.protocol.SignatoriesResponse.keys)
}
inline void SignatoriesResponse::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.SignatoriesResponse.keys)
}
inline std::string* SignatoriesResponse::_internal_add_keys() {
  return keys_.Add();
}
inline void SignatoriesResponse::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:iroha.protocol.SignatoriesResponse.keys)
}
inline void SignatoriesResponse::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:iroha.protocol.SignatoriesResponse.keys)
}
inline void SignatoriesResponse::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:iroha.protocol.SignatoriesResponse.keys)
}
inline void SignatoriesResponse::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:iroha.protocol.SignatoriesResponse.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SignatoriesResponse::keys() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.SignatoriesResponse.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SignatoriesResponse::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.SignatoriesResponse.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// TransactionsResponse

// repeated .iroha.protocol.Transaction transactions = 1;
inline int TransactionsResponse::_internal_transactions_size() const {
  return transactions_.size();
}
inline int TransactionsResponse::transactions_size() const {
  return _internal_transactions_size();
}
inline ::iroha::protocol::Transaction* TransactionsResponse::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransactionsResponse.transactions)
  return transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction >*
TransactionsResponse::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.TransactionsResponse.transactions)
  return &transactions_;
}
inline const ::iroha::protocol::Transaction& TransactionsResponse::_internal_transactions(int index) const {
  return transactions_.Get(index);
}
inline const ::iroha::protocol::Transaction& TransactionsResponse::transactions(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransactionsResponse.transactions)
  return _internal_transactions(index);
}
inline ::iroha::protocol::Transaction* TransactionsResponse::_internal_add_transactions() {
  return transactions_.Add();
}
inline ::iroha::protocol::Transaction* TransactionsResponse::add_transactions() {
  // @@protoc_insertion_point(field_add:iroha.protocol.TransactionsResponse.transactions)
  return _internal_add_transactions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction >&
TransactionsResponse::transactions() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.TransactionsResponse.transactions)
  return transactions_;
}

// -------------------------------------------------------------------

// TransactionsPageResponse

// repeated .iroha.protocol.Transaction transactions = 1;
inline int TransactionsPageResponse::_internal_transactions_size() const {
  return transactions_.size();
}
inline int TransactionsPageResponse::transactions_size() const {
  return _internal_transactions_size();
}
inline ::iroha::protocol::Transaction* TransactionsPageResponse::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransactionsPageResponse.transactions)
  return transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction >*
TransactionsPageResponse::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.TransactionsPageResponse.transactions)
  return &transactions_;
}
inline const ::iroha::protocol::Transaction& TransactionsPageResponse::_internal_transactions(int index) const {
  return transactions_.Get(index);
}
inline const ::iroha::protocol::Transaction& TransactionsPageResponse::transactions(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransactionsPageResponse.transactions)
  return _internal_transactions(index);
}
inline ::iroha::protocol::Transaction* TransactionsPageResponse::_internal_add_transactions() {
  return transactions_.Add();
}
inline ::iroha::protocol::Transaction* TransactionsPageResponse::add_transactions() {
  // @@protoc_insertion_point(field_add:iroha.protocol.TransactionsPageResponse.transactions)
  return _internal_add_transactions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction >&
TransactionsPageResponse::transactions() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.TransactionsPageResponse.transactions)
  return transactions_;
}

// uint32 all_transactions_size = 2;
inline void TransactionsPageResponse::clear_all_transactions_size() {
  all_transactions_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransactionsPageResponse::_internal_all_transactions_size() const {
  return all_transactions_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransactionsPageResponse::all_transactions_size() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransactionsPageResponse.all_transactions_size)
  return _internal_all_transactions_size();
}
inline void TransactionsPageResponse::_internal_set_all_transactions_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  all_transactions_size_ = value;
}
inline void TransactionsPageResponse::set_all_transactions_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_all_transactions_size(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.TransactionsPageResponse.all_transactions_size)
}

// string next_tx_hash = 3;
inline bool TransactionsPageResponse::_internal_has_next_tx_hash() const {
  return next_page_tag_case() == kNextTxHash;
}
inline bool TransactionsPageResponse::has_next_tx_hash() const {
  return _internal_has_next_tx_hash();
}
inline void TransactionsPageResponse::set_has_next_tx_hash() {
  _oneof_case_[0] = kNextTxHash;
}
inline void TransactionsPageResponse::clear_next_tx_hash() {
  if (_internal_has_next_tx_hash()) {
    next_page_tag_.next_tx_hash_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_next_page_tag();
  }
}
inline const std::string& TransactionsPageResponse::next_tx_hash() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.TransactionsPageResponse.next_tx_hash)
  return _internal_next_tx_hash();
}
inline void TransactionsPageResponse::set_next_tx_hash(const std::string& value) {
  _internal_set_next_tx_hash(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.TransactionsPageResponse.next_tx_hash)
}
inline std::string* TransactionsPageResponse::mutable_next_tx_hash() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.TransactionsPageResponse.next_tx_hash)
  return _internal_mutable_next_tx_hash();
}
inline const std::string& TransactionsPageResponse::_internal_next_tx_hash() const {
  if (_internal_has_next_tx_hash()) {
    return next_page_tag_.next_tx_hash_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TransactionsPageResponse::_internal_set_next_tx_hash(const std::string& value) {
  if (!_internal_has_next_tx_hash()) {
    clear_next_page_tag();
    set_has_next_tx_hash();
    next_page_tag_.next_tx_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  next_page_tag_.next_tx_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TransactionsPageResponse::set_next_tx_hash(std::string&& value) {
  // @@protoc_insertion_point(field_set:iroha.protocol.TransactionsPageResponse.next_tx_hash)
  if (!_internal_has_next_tx_hash()) {
    clear_next_page_tag();
    set_has_next_tx_hash();
    next_page_tag_.next_tx_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  next_page_tag_.next_tx_hash_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.TransactionsPageResponse.next_tx_hash)
}
inline void TransactionsPageResponse::set_next_tx_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_next_tx_hash()) {
    clear_next_page_tag();
    set_has_next_tx_hash();
    next_page_tag_.next_tx_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  next_page_tag_.next_tx_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.TransactionsPageResponse.next_tx_hash)
}
inline void TransactionsPageResponse::set_next_tx_hash(const char* value,
                             size_t size) {
  if (!_internal_has_next_tx_hash()) {
    clear_next_page_tag();
    set_has_next_tx_hash();
    next_page_tag_.next_tx_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  next_page_tag_.next_tx_hash_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.TransactionsPageResponse.next_tx_hash)
}
inline std::string* TransactionsPageResponse::_internal_mutable_next_tx_hash() {
  if (!_internal_has_next_tx_hash()) {
    clear_next_page_tag();
    set_has_next_tx_hash();
    next_page_tag_.next_tx_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return next_page_tag_.next_tx_hash_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TransactionsPageResponse::release_next_tx_hash() {
  // @@protoc_insertion_point(field_release:iroha.protocol.TransactionsPageResponse.next_tx_hash)
  if (_internal_has_next_tx_hash()) {
    clear_has_next_page_tag();
    return next_page_tag_.next_tx_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void TransactionsPageResponse::set_allocated_next_tx_hash(std::string* next_tx_hash) {
  if (has_next_page_tag()) {
    clear_next_page_tag();
  }
  if (next_tx_hash != nullptr) {
    set_has_next_tx_hash();
    next_page_tag_.next_tx_hash_.UnsafeSetDefault(next_tx_hash);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(next_tx_hash);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.TransactionsPageResponse.next_tx_hash)
}

inline bool TransactionsPageResponse::has_next_page_tag() const {
  return next_page_tag_case() != NEXT_PAGE_TAG_NOT_SET;
}
inline void TransactionsPageResponse::clear_has_next_page_tag() {
  _oneof_case_[0] = NEXT_PAGE_TAG_NOT_SET;
}
inline TransactionsPageResponse::NextPageTagCase TransactionsPageResponse::next_page_tag_case() const {
  return TransactionsPageResponse::NextPageTagCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PendingTransactionsPageResponse_BatchInfo

// string first_tx_hash = 1;
inline void PendingTransactionsPageResponse_BatchInfo::clear_first_tx_hash() {
  first_tx_hash_.ClearToEmpty();
}
inline const std::string& PendingTransactionsPageResponse_BatchInfo::first_tx_hash() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.PendingTransactionsPageResponse.BatchInfo.first_tx_hash)
  return _internal_first_tx_hash();
}
inline void PendingTransactionsPageResponse_BatchInfo::set_first_tx_hash(const std::string& value) {
  _internal_set_first_tx_hash(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.PendingTransactionsPageResponse.BatchInfo.first_tx_hash)
}
inline std::string* PendingTransactionsPageResponse_BatchInfo::mutable_first_tx_hash() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.PendingTransactionsPageResponse.BatchInfo.first_tx_hash)
  return _internal_mutable_first_tx_hash();
}
inline const std::string& PendingTransactionsPageResponse_BatchInfo::_internal_first_tx_hash() const {
  return first_tx_hash_.Get();
}
inline void PendingTransactionsPageResponse_BatchInfo::_internal_set_first_tx_hash(const std::string& value) {
  
  first_tx_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PendingTransactionsPageResponse_BatchInfo::set_first_tx_hash(std::string&& value) {
  
  first_tx_hash_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.PendingTransactionsPageResponse.BatchInfo.first_tx_hash)
}
inline void PendingTransactionsPageResponse_BatchInfo::set_first_tx_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  first_tx_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.PendingTransactionsPageResponse.BatchInfo.first_tx_hash)
}
inline void PendingTransactionsPageResponse_BatchInfo::set_first_tx_hash(const char* value,
    size_t size) {
  
  first_tx_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.PendingTransactionsPageResponse.BatchInfo.first_tx_hash)
}
inline std::string* PendingTransactionsPageResponse_BatchInfo::_internal_mutable_first_tx_hash() {
  
  return first_tx_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PendingTransactionsPageResponse_BatchInfo::release_first_tx_hash() {
  // @@protoc_insertion_point(field_release:iroha.protocol.PendingTransactionsPageResponse.BatchInfo.first_tx_hash)
  return first_tx_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PendingTransactionsPageResponse_BatchInfo::set_allocated_first_tx_hash(std::string* first_tx_hash) {
  if (first_tx_hash != nullptr) {
    
  } else {
    
  }
  first_tx_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), first_tx_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.PendingTransactionsPageResponse.BatchInfo.first_tx_hash)
}

// uint32 batch_size = 2;
inline void PendingTransactionsPageResponse_BatchInfo::clear_batch_size() {
  batch_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PendingTransactionsPageResponse_BatchInfo::_internal_batch_size() const {
  return batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PendingTransactionsPageResponse_BatchInfo::batch_size() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.PendingTransactionsPageResponse.BatchInfo.batch_size)
  return _internal_batch_size();
}
inline void PendingTransactionsPageResponse_BatchInfo::_internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  batch_size_ = value;
}
inline void PendingTransactionsPageResponse_BatchInfo::set_batch_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.PendingTransactionsPageResponse.BatchInfo.batch_size)
}

// -------------------------------------------------------------------

// PendingTransactionsPageResponse

// repeated .iroha.protocol.Transaction transactions = 1;
inline int PendingTransactionsPageResponse::_internal_transactions_size() const {
  return transactions_.size();
}
inline int PendingTransactionsPageResponse::transactions_size() const {
  return _internal_transactions_size();
}
inline ::iroha::protocol::Transaction* PendingTransactionsPageResponse::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.PendingTransactionsPageResponse.transactions)
  return transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction >*
PendingTransactionsPageResponse::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.PendingTransactionsPageResponse.transactions)
  return &transactions_;
}
inline const ::iroha::protocol::Transaction& PendingTransactionsPageResponse::_internal_transactions(int index) const {
  return transactions_.Get(index);
}
inline const ::iroha::protocol::Transaction& PendingTransactionsPageResponse::transactions(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.PendingTransactionsPageResponse.transactions)
  return _internal_transactions(index);
}
inline ::iroha::protocol::Transaction* PendingTransactionsPageResponse::_internal_add_transactions() {
  return transactions_.Add();
}
inline ::iroha::protocol::Transaction* PendingTransactionsPageResponse::add_transactions() {
  // @@protoc_insertion_point(field_add:iroha.protocol.PendingTransactionsPageResponse.transactions)
  return _internal_add_transactions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Transaction >&
PendingTransactionsPageResponse::transactions() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.PendingTransactionsPageResponse.transactions)
  return transactions_;
}

// uint32 all_transactions_size = 2;
inline void PendingTransactionsPageResponse::clear_all_transactions_size() {
  all_transactions_size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PendingTransactionsPageResponse::_internal_all_transactions_size() const {
  return all_transactions_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PendingTransactionsPageResponse::all_transactions_size() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.PendingTransactionsPageResponse.all_transactions_size)
  return _internal_all_transactions_size();
}
inline void PendingTransactionsPageResponse::_internal_set_all_transactions_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  all_transactions_size_ = value;
}
inline void PendingTransactionsPageResponse::set_all_transactions_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_all_transactions_size(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.PendingTransactionsPageResponse.all_transactions_size)
}

// .iroha.protocol.PendingTransactionsPageResponse.BatchInfo next_batch_info = 3;
inline bool PendingTransactionsPageResponse::_internal_has_next_batch_info() const {
  return this != internal_default_instance() && next_batch_info_ != nullptr;
}
inline bool PendingTransactionsPageResponse::has_next_batch_info() const {
  return _internal_has_next_batch_info();
}
inline void PendingTransactionsPageResponse::clear_next_batch_info() {
  if (GetArena() == nullptr && next_batch_info_ != nullptr) {
    delete next_batch_info_;
  }
  next_batch_info_ = nullptr;
}
inline const ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo& PendingTransactionsPageResponse::_internal_next_batch_info() const {
  const ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* p = next_batch_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo&>(
      ::iroha::protocol::_PendingTransactionsPageResponse_BatchInfo_default_instance_);
}
inline const ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo& PendingTransactionsPageResponse::next_batch_info() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.PendingTransactionsPageResponse.next_batch_info)
  return _internal_next_batch_info();
}
inline void PendingTransactionsPageResponse::unsafe_arena_set_allocated_next_batch_info(
    ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* next_batch_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(next_batch_info_);
  }
  next_batch_info_ = next_batch_info;
  if (next_batch_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.PendingTransactionsPageResponse.next_batch_info)
}
inline ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* PendingTransactionsPageResponse::release_next_batch_info() {
  
  ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* temp = next_batch_info_;
  next_batch_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* PendingTransactionsPageResponse::unsafe_arena_release_next_batch_info() {
  // @@protoc_insertion_point(field_release:iroha.protocol.PendingTransactionsPageResponse.next_batch_info)
  
  ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* temp = next_batch_info_;
  next_batch_info_ = nullptr;
  return temp;
}
inline ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* PendingTransactionsPageResponse::_internal_mutable_next_batch_info() {
  
  if (next_batch_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::PendingTransactionsPageResponse_BatchInfo>(GetArena());
    next_batch_info_ = p;
  }
  return next_batch_info_;
}
inline ::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* PendingTransactionsPageResponse::mutable_next_batch_info() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.PendingTransactionsPageResponse.next_batch_info)
  return _internal_mutable_next_batch_info();
}
inline void PendingTransactionsPageResponse::set_allocated_next_batch_info(::iroha::protocol::PendingTransactionsPageResponse_BatchInfo* next_batch_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete next_batch_info_;
  }
  if (next_batch_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(next_batch_info);
    if (message_arena != submessage_arena) {
      next_batch_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_batch_info, submessage_arena);
    }
    
  } else {
    
  }
  next_batch_info_ = next_batch_info;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.PendingTransactionsPageResponse.next_batch_info)
}

// -------------------------------------------------------------------

// PeersResponse

// repeated .iroha.protocol.Peer peers = 1;
inline int PeersResponse::_internal_peers_size() const {
  return peers_.size();
}
inline int PeersResponse::peers_size() const {
  return _internal_peers_size();
}
inline ::iroha::protocol::Peer* PeersResponse::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.PeersResponse.peers)
  return peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Peer >*
PeersResponse::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.PeersResponse.peers)
  return &peers_;
}
inline const ::iroha::protocol::Peer& PeersResponse::_internal_peers(int index) const {
  return peers_.Get(index);
}
inline const ::iroha::protocol::Peer& PeersResponse::peers(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.PeersResponse.peers)
  return _internal_peers(index);
}
inline ::iroha::protocol::Peer* PeersResponse::_internal_add_peers() {
  return peers_.Add();
}
inline ::iroha::protocol::Peer* PeersResponse::add_peers() {
  // @@protoc_insertion_point(field_add:iroha.protocol.PeersResponse.peers)
  return _internal_add_peers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::Peer >&
PeersResponse::peers() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.PeersResponse.peers)
  return peers_;
}

// -------------------------------------------------------------------

// EngineReceiptsResponse

// repeated .iroha.protocol.EngineReceipt engine_receipts = 1;
inline int EngineReceiptsResponse::_internal_engine_receipts_size() const {
  return engine_receipts_.size();
}
inline int EngineReceiptsResponse::engine_receipts_size() const {
  return _internal_engine_receipts_size();
}
inline ::iroha::protocol::EngineReceipt* EngineReceiptsResponse::mutable_engine_receipts(int index) {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.EngineReceiptsResponse.engine_receipts)
  return engine_receipts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::EngineReceipt >*
EngineReceiptsResponse::mutable_engine_receipts() {
  // @@protoc_insertion_point(field_mutable_list:iroha.protocol.EngineReceiptsResponse.engine_receipts)
  return &engine_receipts_;
}
inline const ::iroha::protocol::EngineReceipt& EngineReceiptsResponse::_internal_engine_receipts(int index) const {
  return engine_receipts_.Get(index);
}
inline const ::iroha::protocol::EngineReceipt& EngineReceiptsResponse::engine_receipts(int index) const {
  // @@protoc_insertion_point(field_get:iroha.protocol.EngineReceiptsResponse.engine_receipts)
  return _internal_engine_receipts(index);
}
inline ::iroha::protocol::EngineReceipt* EngineReceiptsResponse::_internal_add_engine_receipts() {
  return engine_receipts_.Add();
}
inline ::iroha::protocol::EngineReceipt* EngineReceiptsResponse::add_engine_receipts() {
  // @@protoc_insertion_point(field_add:iroha.protocol.EngineReceiptsResponse.engine_receipts)
  return _internal_add_engine_receipts();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::iroha::protocol::EngineReceipt >&
EngineReceiptsResponse::engine_receipts() const {
  // @@protoc_insertion_point(field_list:iroha.protocol.EngineReceiptsResponse.engine_receipts)
  return engine_receipts_;
}

// -------------------------------------------------------------------

// QueryResponse

// .iroha.protocol.AccountAssetResponse account_assets_response = 1;
inline bool QueryResponse::_internal_has_account_assets_response() const {
  return response_case() == kAccountAssetsResponse;
}
inline bool QueryResponse::has_account_assets_response() const {
  return _internal_has_account_assets_response();
}
inline void QueryResponse::set_has_account_assets_response() {
  _oneof_case_[0] = kAccountAssetsResponse;
}
inline void QueryResponse::clear_account_assets_response() {
  if (_internal_has_account_assets_response()) {
    if (GetArena() == nullptr) {
      delete response_.account_assets_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::AccountAssetResponse* QueryResponse::release_account_assets_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.account_assets_response)
  if (_internal_has_account_assets_response()) {
    clear_has_response();
      ::iroha::protocol::AccountAssetResponse* temp = response_.account_assets_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.account_assets_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::AccountAssetResponse& QueryResponse::_internal_account_assets_response() const {
  return _internal_has_account_assets_response()
      ? *response_.account_assets_response_
      : reinterpret_cast< ::iroha::protocol::AccountAssetResponse&>(::iroha::protocol::_AccountAssetResponse_default_instance_);
}
inline const ::iroha::protocol::AccountAssetResponse& QueryResponse::account_assets_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.account_assets_response)
  return _internal_account_assets_response();
}
inline ::iroha::protocol::AccountAssetResponse* QueryResponse::unsafe_arena_release_account_assets_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.account_assets_response)
  if (_internal_has_account_assets_response()) {
    clear_has_response();
    ::iroha::protocol::AccountAssetResponse* temp = response_.account_assets_response_;
    response_.account_assets_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_account_assets_response(::iroha::protocol::AccountAssetResponse* account_assets_response) {
  clear_response();
  if (account_assets_response) {
    set_has_account_assets_response();
    response_.account_assets_response_ = account_assets_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.account_assets_response)
}
inline ::iroha::protocol::AccountAssetResponse* QueryResponse::_internal_mutable_account_assets_response() {
  if (!_internal_has_account_assets_response()) {
    clear_response();
    set_has_account_assets_response();
    response_.account_assets_response_ = CreateMaybeMessage< ::iroha::protocol::AccountAssetResponse >(GetArena());
  }
  return response_.account_assets_response_;
}
inline ::iroha::protocol::AccountAssetResponse* QueryResponse::mutable_account_assets_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.account_assets_response)
  return _internal_mutable_account_assets_response();
}

// .iroha.protocol.AccountDetailResponse account_detail_response = 2;
inline bool QueryResponse::_internal_has_account_detail_response() const {
  return response_case() == kAccountDetailResponse;
}
inline bool QueryResponse::has_account_detail_response() const {
  return _internal_has_account_detail_response();
}
inline void QueryResponse::set_has_account_detail_response() {
  _oneof_case_[0] = kAccountDetailResponse;
}
inline void QueryResponse::clear_account_detail_response() {
  if (_internal_has_account_detail_response()) {
    if (GetArena() == nullptr) {
      delete response_.account_detail_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::AccountDetailResponse* QueryResponse::release_account_detail_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.account_detail_response)
  if (_internal_has_account_detail_response()) {
    clear_has_response();
      ::iroha::protocol::AccountDetailResponse* temp = response_.account_detail_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.account_detail_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::AccountDetailResponse& QueryResponse::_internal_account_detail_response() const {
  return _internal_has_account_detail_response()
      ? *response_.account_detail_response_
      : reinterpret_cast< ::iroha::protocol::AccountDetailResponse&>(::iroha::protocol::_AccountDetailResponse_default_instance_);
}
inline const ::iroha::protocol::AccountDetailResponse& QueryResponse::account_detail_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.account_detail_response)
  return _internal_account_detail_response();
}
inline ::iroha::protocol::AccountDetailResponse* QueryResponse::unsafe_arena_release_account_detail_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.account_detail_response)
  if (_internal_has_account_detail_response()) {
    clear_has_response();
    ::iroha::protocol::AccountDetailResponse* temp = response_.account_detail_response_;
    response_.account_detail_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_account_detail_response(::iroha::protocol::AccountDetailResponse* account_detail_response) {
  clear_response();
  if (account_detail_response) {
    set_has_account_detail_response();
    response_.account_detail_response_ = account_detail_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.account_detail_response)
}
inline ::iroha::protocol::AccountDetailResponse* QueryResponse::_internal_mutable_account_detail_response() {
  if (!_internal_has_account_detail_response()) {
    clear_response();
    set_has_account_detail_response();
    response_.account_detail_response_ = CreateMaybeMessage< ::iroha::protocol::AccountDetailResponse >(GetArena());
  }
  return response_.account_detail_response_;
}
inline ::iroha::protocol::AccountDetailResponse* QueryResponse::mutable_account_detail_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.account_detail_response)
  return _internal_mutable_account_detail_response();
}

// .iroha.protocol.AccountResponse account_response = 3;
inline bool QueryResponse::_internal_has_account_response() const {
  return response_case() == kAccountResponse;
}
inline bool QueryResponse::has_account_response() const {
  return _internal_has_account_response();
}
inline void QueryResponse::set_has_account_response() {
  _oneof_case_[0] = kAccountResponse;
}
inline void QueryResponse::clear_account_response() {
  if (_internal_has_account_response()) {
    if (GetArena() == nullptr) {
      delete response_.account_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::AccountResponse* QueryResponse::release_account_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.account_response)
  if (_internal_has_account_response()) {
    clear_has_response();
      ::iroha::protocol::AccountResponse* temp = response_.account_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.account_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::AccountResponse& QueryResponse::_internal_account_response() const {
  return _internal_has_account_response()
      ? *response_.account_response_
      : reinterpret_cast< ::iroha::protocol::AccountResponse&>(::iroha::protocol::_AccountResponse_default_instance_);
}
inline const ::iroha::protocol::AccountResponse& QueryResponse::account_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.account_response)
  return _internal_account_response();
}
inline ::iroha::protocol::AccountResponse* QueryResponse::unsafe_arena_release_account_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.account_response)
  if (_internal_has_account_response()) {
    clear_has_response();
    ::iroha::protocol::AccountResponse* temp = response_.account_response_;
    response_.account_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_account_response(::iroha::protocol::AccountResponse* account_response) {
  clear_response();
  if (account_response) {
    set_has_account_response();
    response_.account_response_ = account_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.account_response)
}
inline ::iroha::protocol::AccountResponse* QueryResponse::_internal_mutable_account_response() {
  if (!_internal_has_account_response()) {
    clear_response();
    set_has_account_response();
    response_.account_response_ = CreateMaybeMessage< ::iroha::protocol::AccountResponse >(GetArena());
  }
  return response_.account_response_;
}
inline ::iroha::protocol::AccountResponse* QueryResponse::mutable_account_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.account_response)
  return _internal_mutable_account_response();
}

// .iroha.protocol.ErrorResponse error_response = 4;
inline bool QueryResponse::_internal_has_error_response() const {
  return response_case() == kErrorResponse;
}
inline bool QueryResponse::has_error_response() const {
  return _internal_has_error_response();
}
inline void QueryResponse::set_has_error_response() {
  _oneof_case_[0] = kErrorResponse;
}
inline void QueryResponse::clear_error_response() {
  if (_internal_has_error_response()) {
    if (GetArena() == nullptr) {
      delete response_.error_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::ErrorResponse* QueryResponse::release_error_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.error_response)
  if (_internal_has_error_response()) {
    clear_has_response();
      ::iroha::protocol::ErrorResponse* temp = response_.error_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.error_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::ErrorResponse& QueryResponse::_internal_error_response() const {
  return _internal_has_error_response()
      ? *response_.error_response_
      : reinterpret_cast< ::iroha::protocol::ErrorResponse&>(::iroha::protocol::_ErrorResponse_default_instance_);
}
inline const ::iroha::protocol::ErrorResponse& QueryResponse::error_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.error_response)
  return _internal_error_response();
}
inline ::iroha::protocol::ErrorResponse* QueryResponse::unsafe_arena_release_error_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.error_response)
  if (_internal_has_error_response()) {
    clear_has_response();
    ::iroha::protocol::ErrorResponse* temp = response_.error_response_;
    response_.error_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_error_response(::iroha::protocol::ErrorResponse* error_response) {
  clear_response();
  if (error_response) {
    set_has_error_response();
    response_.error_response_ = error_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.error_response)
}
inline ::iroha::protocol::ErrorResponse* QueryResponse::_internal_mutable_error_response() {
  if (!_internal_has_error_response()) {
    clear_response();
    set_has_error_response();
    response_.error_response_ = CreateMaybeMessage< ::iroha::protocol::ErrorResponse >(GetArena());
  }
  return response_.error_response_;
}
inline ::iroha::protocol::ErrorResponse* QueryResponse::mutable_error_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.error_response)
  return _internal_mutable_error_response();
}

// .iroha.protocol.SignatoriesResponse signatories_response = 5;
inline bool QueryResponse::_internal_has_signatories_response() const {
  return response_case() == kSignatoriesResponse;
}
inline bool QueryResponse::has_signatories_response() const {
  return _internal_has_signatories_response();
}
inline void QueryResponse::set_has_signatories_response() {
  _oneof_case_[0] = kSignatoriesResponse;
}
inline void QueryResponse::clear_signatories_response() {
  if (_internal_has_signatories_response()) {
    if (GetArena() == nullptr) {
      delete response_.signatories_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::SignatoriesResponse* QueryResponse::release_signatories_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.signatories_response)
  if (_internal_has_signatories_response()) {
    clear_has_response();
      ::iroha::protocol::SignatoriesResponse* temp = response_.signatories_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.signatories_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::SignatoriesResponse& QueryResponse::_internal_signatories_response() const {
  return _internal_has_signatories_response()
      ? *response_.signatories_response_
      : reinterpret_cast< ::iroha::protocol::SignatoriesResponse&>(::iroha::protocol::_SignatoriesResponse_default_instance_);
}
inline const ::iroha::protocol::SignatoriesResponse& QueryResponse::signatories_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.signatories_response)
  return _internal_signatories_response();
}
inline ::iroha::protocol::SignatoriesResponse* QueryResponse::unsafe_arena_release_signatories_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.signatories_response)
  if (_internal_has_signatories_response()) {
    clear_has_response();
    ::iroha::protocol::SignatoriesResponse* temp = response_.signatories_response_;
    response_.signatories_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_signatories_response(::iroha::protocol::SignatoriesResponse* signatories_response) {
  clear_response();
  if (signatories_response) {
    set_has_signatories_response();
    response_.signatories_response_ = signatories_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.signatories_response)
}
inline ::iroha::protocol::SignatoriesResponse* QueryResponse::_internal_mutable_signatories_response() {
  if (!_internal_has_signatories_response()) {
    clear_response();
    set_has_signatories_response();
    response_.signatories_response_ = CreateMaybeMessage< ::iroha::protocol::SignatoriesResponse >(GetArena());
  }
  return response_.signatories_response_;
}
inline ::iroha::protocol::SignatoriesResponse* QueryResponse::mutable_signatories_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.signatories_response)
  return _internal_mutable_signatories_response();
}

// .iroha.protocol.TransactionsResponse transactions_response = 6;
inline bool QueryResponse::_internal_has_transactions_response() const {
  return response_case() == kTransactionsResponse;
}
inline bool QueryResponse::has_transactions_response() const {
  return _internal_has_transactions_response();
}
inline void QueryResponse::set_has_transactions_response() {
  _oneof_case_[0] = kTransactionsResponse;
}
inline void QueryResponse::clear_transactions_response() {
  if (_internal_has_transactions_response()) {
    if (GetArena() == nullptr) {
      delete response_.transactions_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::TransactionsResponse* QueryResponse::release_transactions_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.transactions_response)
  if (_internal_has_transactions_response()) {
    clear_has_response();
      ::iroha::protocol::TransactionsResponse* temp = response_.transactions_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.transactions_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::TransactionsResponse& QueryResponse::_internal_transactions_response() const {
  return _internal_has_transactions_response()
      ? *response_.transactions_response_
      : reinterpret_cast< ::iroha::protocol::TransactionsResponse&>(::iroha::protocol::_TransactionsResponse_default_instance_);
}
inline const ::iroha::protocol::TransactionsResponse& QueryResponse::transactions_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.transactions_response)
  return _internal_transactions_response();
}
inline ::iroha::protocol::TransactionsResponse* QueryResponse::unsafe_arena_release_transactions_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.transactions_response)
  if (_internal_has_transactions_response()) {
    clear_has_response();
    ::iroha::protocol::TransactionsResponse* temp = response_.transactions_response_;
    response_.transactions_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_transactions_response(::iroha::protocol::TransactionsResponse* transactions_response) {
  clear_response();
  if (transactions_response) {
    set_has_transactions_response();
    response_.transactions_response_ = transactions_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.transactions_response)
}
inline ::iroha::protocol::TransactionsResponse* QueryResponse::_internal_mutable_transactions_response() {
  if (!_internal_has_transactions_response()) {
    clear_response();
    set_has_transactions_response();
    response_.transactions_response_ = CreateMaybeMessage< ::iroha::protocol::TransactionsResponse >(GetArena());
  }
  return response_.transactions_response_;
}
inline ::iroha::protocol::TransactionsResponse* QueryResponse::mutable_transactions_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.transactions_response)
  return _internal_mutable_transactions_response();
}

// .iroha.protocol.AssetResponse asset_response = 7;
inline bool QueryResponse::_internal_has_asset_response() const {
  return response_case() == kAssetResponse;
}
inline bool QueryResponse::has_asset_response() const {
  return _internal_has_asset_response();
}
inline void QueryResponse::set_has_asset_response() {
  _oneof_case_[0] = kAssetResponse;
}
inline void QueryResponse::clear_asset_response() {
  if (_internal_has_asset_response()) {
    if (GetArena() == nullptr) {
      delete response_.asset_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::AssetResponse* QueryResponse::release_asset_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.asset_response)
  if (_internal_has_asset_response()) {
    clear_has_response();
      ::iroha::protocol::AssetResponse* temp = response_.asset_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.asset_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::AssetResponse& QueryResponse::_internal_asset_response() const {
  return _internal_has_asset_response()
      ? *response_.asset_response_
      : reinterpret_cast< ::iroha::protocol::AssetResponse&>(::iroha::protocol::_AssetResponse_default_instance_);
}
inline const ::iroha::protocol::AssetResponse& QueryResponse::asset_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.asset_response)
  return _internal_asset_response();
}
inline ::iroha::protocol::AssetResponse* QueryResponse::unsafe_arena_release_asset_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.asset_response)
  if (_internal_has_asset_response()) {
    clear_has_response();
    ::iroha::protocol::AssetResponse* temp = response_.asset_response_;
    response_.asset_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_asset_response(::iroha::protocol::AssetResponse* asset_response) {
  clear_response();
  if (asset_response) {
    set_has_asset_response();
    response_.asset_response_ = asset_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.asset_response)
}
inline ::iroha::protocol::AssetResponse* QueryResponse::_internal_mutable_asset_response() {
  if (!_internal_has_asset_response()) {
    clear_response();
    set_has_asset_response();
    response_.asset_response_ = CreateMaybeMessage< ::iroha::protocol::AssetResponse >(GetArena());
  }
  return response_.asset_response_;
}
inline ::iroha::protocol::AssetResponse* QueryResponse::mutable_asset_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.asset_response)
  return _internal_mutable_asset_response();
}

// .iroha.protocol.RolesResponse roles_response = 8;
inline bool QueryResponse::_internal_has_roles_response() const {
  return response_case() == kRolesResponse;
}
inline bool QueryResponse::has_roles_response() const {
  return _internal_has_roles_response();
}
inline void QueryResponse::set_has_roles_response() {
  _oneof_case_[0] = kRolesResponse;
}
inline void QueryResponse::clear_roles_response() {
  if (_internal_has_roles_response()) {
    if (GetArena() == nullptr) {
      delete response_.roles_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::RolesResponse* QueryResponse::release_roles_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.roles_response)
  if (_internal_has_roles_response()) {
    clear_has_response();
      ::iroha::protocol::RolesResponse* temp = response_.roles_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.roles_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::RolesResponse& QueryResponse::_internal_roles_response() const {
  return _internal_has_roles_response()
      ? *response_.roles_response_
      : reinterpret_cast< ::iroha::protocol::RolesResponse&>(::iroha::protocol::_RolesResponse_default_instance_);
}
inline const ::iroha::protocol::RolesResponse& QueryResponse::roles_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.roles_response)
  return _internal_roles_response();
}
inline ::iroha::protocol::RolesResponse* QueryResponse::unsafe_arena_release_roles_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.roles_response)
  if (_internal_has_roles_response()) {
    clear_has_response();
    ::iroha::protocol::RolesResponse* temp = response_.roles_response_;
    response_.roles_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_roles_response(::iroha::protocol::RolesResponse* roles_response) {
  clear_response();
  if (roles_response) {
    set_has_roles_response();
    response_.roles_response_ = roles_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.roles_response)
}
inline ::iroha::protocol::RolesResponse* QueryResponse::_internal_mutable_roles_response() {
  if (!_internal_has_roles_response()) {
    clear_response();
    set_has_roles_response();
    response_.roles_response_ = CreateMaybeMessage< ::iroha::protocol::RolesResponse >(GetArena());
  }
  return response_.roles_response_;
}
inline ::iroha::protocol::RolesResponse* QueryResponse::mutable_roles_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.roles_response)
  return _internal_mutable_roles_response();
}

// .iroha.protocol.RolePermissionsResponse role_permissions_response = 9;
inline bool QueryResponse::_internal_has_role_permissions_response() const {
  return response_case() == kRolePermissionsResponse;
}
inline bool QueryResponse::has_role_permissions_response() const {
  return _internal_has_role_permissions_response();
}
inline void QueryResponse::set_has_role_permissions_response() {
  _oneof_case_[0] = kRolePermissionsResponse;
}
inline void QueryResponse::clear_role_permissions_response() {
  if (_internal_has_role_permissions_response()) {
    if (GetArena() == nullptr) {
      delete response_.role_permissions_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::RolePermissionsResponse* QueryResponse::release_role_permissions_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.role_permissions_response)
  if (_internal_has_role_permissions_response()) {
    clear_has_response();
      ::iroha::protocol::RolePermissionsResponse* temp = response_.role_permissions_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.role_permissions_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::RolePermissionsResponse& QueryResponse::_internal_role_permissions_response() const {
  return _internal_has_role_permissions_response()
      ? *response_.role_permissions_response_
      : reinterpret_cast< ::iroha::protocol::RolePermissionsResponse&>(::iroha::protocol::_RolePermissionsResponse_default_instance_);
}
inline const ::iroha::protocol::RolePermissionsResponse& QueryResponse::role_permissions_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.role_permissions_response)
  return _internal_role_permissions_response();
}
inline ::iroha::protocol::RolePermissionsResponse* QueryResponse::unsafe_arena_release_role_permissions_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.role_permissions_response)
  if (_internal_has_role_permissions_response()) {
    clear_has_response();
    ::iroha::protocol::RolePermissionsResponse* temp = response_.role_permissions_response_;
    response_.role_permissions_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_role_permissions_response(::iroha::protocol::RolePermissionsResponse* role_permissions_response) {
  clear_response();
  if (role_permissions_response) {
    set_has_role_permissions_response();
    response_.role_permissions_response_ = role_permissions_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.role_permissions_response)
}
inline ::iroha::protocol::RolePermissionsResponse* QueryResponse::_internal_mutable_role_permissions_response() {
  if (!_internal_has_role_permissions_response()) {
    clear_response();
    set_has_role_permissions_response();
    response_.role_permissions_response_ = CreateMaybeMessage< ::iroha::protocol::RolePermissionsResponse >(GetArena());
  }
  return response_.role_permissions_response_;
}
inline ::iroha::protocol::RolePermissionsResponse* QueryResponse::mutable_role_permissions_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.role_permissions_response)
  return _internal_mutable_role_permissions_response();
}

// .iroha.protocol.TransactionsPageResponse transactions_page_response = 11;
inline bool QueryResponse::_internal_has_transactions_page_response() const {
  return response_case() == kTransactionsPageResponse;
}
inline bool QueryResponse::has_transactions_page_response() const {
  return _internal_has_transactions_page_response();
}
inline void QueryResponse::set_has_transactions_page_response() {
  _oneof_case_[0] = kTransactionsPageResponse;
}
inline void QueryResponse::clear_transactions_page_response() {
  if (_internal_has_transactions_page_response()) {
    if (GetArena() == nullptr) {
      delete response_.transactions_page_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::TransactionsPageResponse* QueryResponse::release_transactions_page_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.transactions_page_response)
  if (_internal_has_transactions_page_response()) {
    clear_has_response();
      ::iroha::protocol::TransactionsPageResponse* temp = response_.transactions_page_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.transactions_page_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::TransactionsPageResponse& QueryResponse::_internal_transactions_page_response() const {
  return _internal_has_transactions_page_response()
      ? *response_.transactions_page_response_
      : reinterpret_cast< ::iroha::protocol::TransactionsPageResponse&>(::iroha::protocol::_TransactionsPageResponse_default_instance_);
}
inline const ::iroha::protocol::TransactionsPageResponse& QueryResponse::transactions_page_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.transactions_page_response)
  return _internal_transactions_page_response();
}
inline ::iroha::protocol::TransactionsPageResponse* QueryResponse::unsafe_arena_release_transactions_page_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.transactions_page_response)
  if (_internal_has_transactions_page_response()) {
    clear_has_response();
    ::iroha::protocol::TransactionsPageResponse* temp = response_.transactions_page_response_;
    response_.transactions_page_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_transactions_page_response(::iroha::protocol::TransactionsPageResponse* transactions_page_response) {
  clear_response();
  if (transactions_page_response) {
    set_has_transactions_page_response();
    response_.transactions_page_response_ = transactions_page_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.transactions_page_response)
}
inline ::iroha::protocol::TransactionsPageResponse* QueryResponse::_internal_mutable_transactions_page_response() {
  if (!_internal_has_transactions_page_response()) {
    clear_response();
    set_has_transactions_page_response();
    response_.transactions_page_response_ = CreateMaybeMessage< ::iroha::protocol::TransactionsPageResponse >(GetArena());
  }
  return response_.transactions_page_response_;
}
inline ::iroha::protocol::TransactionsPageResponse* QueryResponse::mutable_transactions_page_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.transactions_page_response)
  return _internal_mutable_transactions_page_response();
}

// .iroha.protocol.PendingTransactionsPageResponse pending_transactions_page_response = 13;
inline bool QueryResponse::_internal_has_pending_transactions_page_response() const {
  return response_case() == kPendingTransactionsPageResponse;
}
inline bool QueryResponse::has_pending_transactions_page_response() const {
  return _internal_has_pending_transactions_page_response();
}
inline void QueryResponse::set_has_pending_transactions_page_response() {
  _oneof_case_[0] = kPendingTransactionsPageResponse;
}
inline void QueryResponse::clear_pending_transactions_page_response() {
  if (_internal_has_pending_transactions_page_response()) {
    if (GetArena() == nullptr) {
      delete response_.pending_transactions_page_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::PendingTransactionsPageResponse* QueryResponse::release_pending_transactions_page_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.pending_transactions_page_response)
  if (_internal_has_pending_transactions_page_response()) {
    clear_has_response();
      ::iroha::protocol::PendingTransactionsPageResponse* temp = response_.pending_transactions_page_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.pending_transactions_page_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::PendingTransactionsPageResponse& QueryResponse::_internal_pending_transactions_page_response() const {
  return _internal_has_pending_transactions_page_response()
      ? *response_.pending_transactions_page_response_
      : reinterpret_cast< ::iroha::protocol::PendingTransactionsPageResponse&>(::iroha::protocol::_PendingTransactionsPageResponse_default_instance_);
}
inline const ::iroha::protocol::PendingTransactionsPageResponse& QueryResponse::pending_transactions_page_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.pending_transactions_page_response)
  return _internal_pending_transactions_page_response();
}
inline ::iroha::protocol::PendingTransactionsPageResponse* QueryResponse::unsafe_arena_release_pending_transactions_page_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.pending_transactions_page_response)
  if (_internal_has_pending_transactions_page_response()) {
    clear_has_response();
    ::iroha::protocol::PendingTransactionsPageResponse* temp = response_.pending_transactions_page_response_;
    response_.pending_transactions_page_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_pending_transactions_page_response(::iroha::protocol::PendingTransactionsPageResponse* pending_transactions_page_response) {
  clear_response();
  if (pending_transactions_page_response) {
    set_has_pending_transactions_page_response();
    response_.pending_transactions_page_response_ = pending_transactions_page_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.pending_transactions_page_response)
}
inline ::iroha::protocol::PendingTransactionsPageResponse* QueryResponse::_internal_mutable_pending_transactions_page_response() {
  if (!_internal_has_pending_transactions_page_response()) {
    clear_response();
    set_has_pending_transactions_page_response();
    response_.pending_transactions_page_response_ = CreateMaybeMessage< ::iroha::protocol::PendingTransactionsPageResponse >(GetArena());
  }
  return response_.pending_transactions_page_response_;
}
inline ::iroha::protocol::PendingTransactionsPageResponse* QueryResponse::mutable_pending_transactions_page_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.pending_transactions_page_response)
  return _internal_mutable_pending_transactions_page_response();
}

// .iroha.protocol.BlockResponse block_response = 12;
inline bool QueryResponse::_internal_has_block_response() const {
  return response_case() == kBlockResponse;
}
inline bool QueryResponse::has_block_response() const {
  return _internal_has_block_response();
}
inline void QueryResponse::set_has_block_response() {
  _oneof_case_[0] = kBlockResponse;
}
inline void QueryResponse::clear_block_response() {
  if (_internal_has_block_response()) {
    if (GetArena() == nullptr) {
      delete response_.block_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::BlockResponse* QueryResponse::release_block_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.block_response)
  if (_internal_has_block_response()) {
    clear_has_response();
      ::iroha::protocol::BlockResponse* temp = response_.block_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.block_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::BlockResponse& QueryResponse::_internal_block_response() const {
  return _internal_has_block_response()
      ? *response_.block_response_
      : reinterpret_cast< ::iroha::protocol::BlockResponse&>(::iroha::protocol::_BlockResponse_default_instance_);
}
inline const ::iroha::protocol::BlockResponse& QueryResponse::block_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.block_response)
  return _internal_block_response();
}
inline ::iroha::protocol::BlockResponse* QueryResponse::unsafe_arena_release_block_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.block_response)
  if (_internal_has_block_response()) {
    clear_has_response();
    ::iroha::protocol::BlockResponse* temp = response_.block_response_;
    response_.block_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_block_response(::iroha::protocol::BlockResponse* block_response) {
  clear_response();
  if (block_response) {
    set_has_block_response();
    response_.block_response_ = block_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.block_response)
}
inline ::iroha::protocol::BlockResponse* QueryResponse::_internal_mutable_block_response() {
  if (!_internal_has_block_response()) {
    clear_response();
    set_has_block_response();
    response_.block_response_ = CreateMaybeMessage< ::iroha::protocol::BlockResponse >(GetArena());
  }
  return response_.block_response_;
}
inline ::iroha::protocol::BlockResponse* QueryResponse::mutable_block_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.block_response)
  return _internal_mutable_block_response();
}

// .iroha.protocol.PeersResponse peers_response = 14;
inline bool QueryResponse::_internal_has_peers_response() const {
  return response_case() == kPeersResponse;
}
inline bool QueryResponse::has_peers_response() const {
  return _internal_has_peers_response();
}
inline void QueryResponse::set_has_peers_response() {
  _oneof_case_[0] = kPeersResponse;
}
inline void QueryResponse::clear_peers_response() {
  if (_internal_has_peers_response()) {
    if (GetArena() == nullptr) {
      delete response_.peers_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::PeersResponse* QueryResponse::release_peers_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.peers_response)
  if (_internal_has_peers_response()) {
    clear_has_response();
      ::iroha::protocol::PeersResponse* temp = response_.peers_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.peers_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::PeersResponse& QueryResponse::_internal_peers_response() const {
  return _internal_has_peers_response()
      ? *response_.peers_response_
      : reinterpret_cast< ::iroha::protocol::PeersResponse&>(::iroha::protocol::_PeersResponse_default_instance_);
}
inline const ::iroha::protocol::PeersResponse& QueryResponse::peers_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.peers_response)
  return _internal_peers_response();
}
inline ::iroha::protocol::PeersResponse* QueryResponse::unsafe_arena_release_peers_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.peers_response)
  if (_internal_has_peers_response()) {
    clear_has_response();
    ::iroha::protocol::PeersResponse* temp = response_.peers_response_;
    response_.peers_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_peers_response(::iroha::protocol::PeersResponse* peers_response) {
  clear_response();
  if (peers_response) {
    set_has_peers_response();
    response_.peers_response_ = peers_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.peers_response)
}
inline ::iroha::protocol::PeersResponse* QueryResponse::_internal_mutable_peers_response() {
  if (!_internal_has_peers_response()) {
    clear_response();
    set_has_peers_response();
    response_.peers_response_ = CreateMaybeMessage< ::iroha::protocol::PeersResponse >(GetArena());
  }
  return response_.peers_response_;
}
inline ::iroha::protocol::PeersResponse* QueryResponse::mutable_peers_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.peers_response)
  return _internal_mutable_peers_response();
}

// .iroha.protocol.EngineReceiptsResponse engine_receipts_response = 15;
inline bool QueryResponse::_internal_has_engine_receipts_response() const {
  return response_case() == kEngineReceiptsResponse;
}
inline bool QueryResponse::has_engine_receipts_response() const {
  return _internal_has_engine_receipts_response();
}
inline void QueryResponse::set_has_engine_receipts_response() {
  _oneof_case_[0] = kEngineReceiptsResponse;
}
inline void QueryResponse::clear_engine_receipts_response() {
  if (_internal_has_engine_receipts_response()) {
    if (GetArena() == nullptr) {
      delete response_.engine_receipts_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::EngineReceiptsResponse* QueryResponse::release_engine_receipts_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.engine_receipts_response)
  if (_internal_has_engine_receipts_response()) {
    clear_has_response();
      ::iroha::protocol::EngineReceiptsResponse* temp = response_.engine_receipts_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.engine_receipts_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::EngineReceiptsResponse& QueryResponse::_internal_engine_receipts_response() const {
  return _internal_has_engine_receipts_response()
      ? *response_.engine_receipts_response_
      : reinterpret_cast< ::iroha::protocol::EngineReceiptsResponse&>(::iroha::protocol::_EngineReceiptsResponse_default_instance_);
}
inline const ::iroha::protocol::EngineReceiptsResponse& QueryResponse::engine_receipts_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.engine_receipts_response)
  return _internal_engine_receipts_response();
}
inline ::iroha::protocol::EngineReceiptsResponse* QueryResponse::unsafe_arena_release_engine_receipts_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.QueryResponse.engine_receipts_response)
  if (_internal_has_engine_receipts_response()) {
    clear_has_response();
    ::iroha::protocol::EngineReceiptsResponse* temp = response_.engine_receipts_response_;
    response_.engine_receipts_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryResponse::unsafe_arena_set_allocated_engine_receipts_response(::iroha::protocol::EngineReceiptsResponse* engine_receipts_response) {
  clear_response();
  if (engine_receipts_response) {
    set_has_engine_receipts_response();
    response_.engine_receipts_response_ = engine_receipts_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.QueryResponse.engine_receipts_response)
}
inline ::iroha::protocol::EngineReceiptsResponse* QueryResponse::_internal_mutable_engine_receipts_response() {
  if (!_internal_has_engine_receipts_response()) {
    clear_response();
    set_has_engine_receipts_response();
    response_.engine_receipts_response_ = CreateMaybeMessage< ::iroha::protocol::EngineReceiptsResponse >(GetArena());
  }
  return response_.engine_receipts_response_;
}
inline ::iroha::protocol::EngineReceiptsResponse* QueryResponse::mutable_engine_receipts_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.engine_receipts_response)
  return _internal_mutable_engine_receipts_response();
}

// string query_hash = 10;
inline void QueryResponse::clear_query_hash() {
  query_hash_.ClearToEmpty();
}
inline const std::string& QueryResponse::query_hash() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.QueryResponse.query_hash)
  return _internal_query_hash();
}
inline void QueryResponse::set_query_hash(const std::string& value) {
  _internal_set_query_hash(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.QueryResponse.query_hash)
}
inline std::string* QueryResponse::mutable_query_hash() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.QueryResponse.query_hash)
  return _internal_mutable_query_hash();
}
inline const std::string& QueryResponse::_internal_query_hash() const {
  return query_hash_.Get();
}
inline void QueryResponse::_internal_set_query_hash(const std::string& value) {
  
  query_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void QueryResponse::set_query_hash(std::string&& value) {
  
  query_hash_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.QueryResponse.query_hash)
}
inline void QueryResponse::set_query_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  query_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.QueryResponse.query_hash)
}
inline void QueryResponse::set_query_hash(const char* value,
    size_t size) {
  
  query_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.QueryResponse.query_hash)
}
inline std::string* QueryResponse::_internal_mutable_query_hash() {
  
  return query_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* QueryResponse::release_query_hash() {
  // @@protoc_insertion_point(field_release:iroha.protocol.QueryResponse.query_hash)
  return query_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void QueryResponse::set_allocated_query_hash(std::string* query_hash) {
  if (query_hash != nullptr) {
    
  } else {
    
  }
  query_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), query_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.QueryResponse.query_hash)
}

inline bool QueryResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void QueryResponse::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline QueryResponse::ResponseCase QueryResponse::response_case() const {
  return QueryResponse::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BlockResponse

// .iroha.protocol.Block block = 1;
inline bool BlockResponse::_internal_has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline bool BlockResponse::has_block() const {
  return _internal_has_block();
}
inline const ::iroha::protocol::Block& BlockResponse::_internal_block() const {
  const ::iroha::protocol::Block* p = block_;
  return p != nullptr ? *p : reinterpret_cast<const ::iroha::protocol::Block&>(
      ::iroha::protocol::_Block_default_instance_);
}
inline const ::iroha::protocol::Block& BlockResponse::block() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.BlockResponse.block)
  return _internal_block();
}
inline void BlockResponse::unsafe_arena_set_allocated_block(
    ::iroha::protocol::Block* block) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.BlockResponse.block)
}
inline ::iroha::protocol::Block* BlockResponse::release_block() {
  
  ::iroha::protocol::Block* temp = block_;
  block_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::iroha::protocol::Block* BlockResponse::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:iroha.protocol.BlockResponse.block)
  
  ::iroha::protocol::Block* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::iroha::protocol::Block* BlockResponse::_internal_mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::iroha::protocol::Block>(GetArena());
    block_ = p;
  }
  return block_;
}
inline ::iroha::protocol::Block* BlockResponse::mutable_block() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.BlockResponse.block)
  return _internal_mutable_block();
}
inline void BlockResponse::set_allocated_block(::iroha::protocol::Block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block)->GetArena();
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.BlockResponse.block)
}

// -------------------------------------------------------------------

// BlockErrorResponse

// string message = 1;
inline void BlockErrorResponse::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& BlockErrorResponse::message() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.BlockErrorResponse.message)
  return _internal_message();
}
inline void BlockErrorResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.BlockErrorResponse.message)
}
inline std::string* BlockErrorResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.BlockErrorResponse.message)
  return _internal_mutable_message();
}
inline const std::string& BlockErrorResponse::_internal_message() const {
  return message_.Get();
}
inline void BlockErrorResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BlockErrorResponse::set_message(std::string&& value) {
  
  message_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:iroha.protocol.BlockErrorResponse.message)
}
inline void BlockErrorResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:iroha.protocol.BlockErrorResponse.message)
}
inline void BlockErrorResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:iroha.protocol.BlockErrorResponse.message)
}
inline std::string* BlockErrorResponse::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BlockErrorResponse::release_message() {
  // @@protoc_insertion_point(field_release:iroha.protocol.BlockErrorResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockErrorResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:iroha.protocol.BlockErrorResponse.message)
}

// -------------------------------------------------------------------

// BlockQueryResponse

// .iroha.protocol.BlockResponse block_response = 1;
inline bool BlockQueryResponse::_internal_has_block_response() const {
  return response_case() == kBlockResponse;
}
inline bool BlockQueryResponse::has_block_response() const {
  return _internal_has_block_response();
}
inline void BlockQueryResponse::set_has_block_response() {
  _oneof_case_[0] = kBlockResponse;
}
inline void BlockQueryResponse::clear_block_response() {
  if (_internal_has_block_response()) {
    if (GetArena() == nullptr) {
      delete response_.block_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::BlockResponse* BlockQueryResponse::release_block_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.BlockQueryResponse.block_response)
  if (_internal_has_block_response()) {
    clear_has_response();
      ::iroha::protocol::BlockResponse* temp = response_.block_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.block_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::BlockResponse& BlockQueryResponse::_internal_block_response() const {
  return _internal_has_block_response()
      ? *response_.block_response_
      : reinterpret_cast< ::iroha::protocol::BlockResponse&>(::iroha::protocol::_BlockResponse_default_instance_);
}
inline const ::iroha::protocol::BlockResponse& BlockQueryResponse::block_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.BlockQueryResponse.block_response)
  return _internal_block_response();
}
inline ::iroha::protocol::BlockResponse* BlockQueryResponse::unsafe_arena_release_block_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.BlockQueryResponse.block_response)
  if (_internal_has_block_response()) {
    clear_has_response();
    ::iroha::protocol::BlockResponse* temp = response_.block_response_;
    response_.block_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlockQueryResponse::unsafe_arena_set_allocated_block_response(::iroha::protocol::BlockResponse* block_response) {
  clear_response();
  if (block_response) {
    set_has_block_response();
    response_.block_response_ = block_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.BlockQueryResponse.block_response)
}
inline ::iroha::protocol::BlockResponse* BlockQueryResponse::_internal_mutable_block_response() {
  if (!_internal_has_block_response()) {
    clear_response();
    set_has_block_response();
    response_.block_response_ = CreateMaybeMessage< ::iroha::protocol::BlockResponse >(GetArena());
  }
  return response_.block_response_;
}
inline ::iroha::protocol::BlockResponse* BlockQueryResponse::mutable_block_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.BlockQueryResponse.block_response)
  return _internal_mutable_block_response();
}

// .iroha.protocol.BlockErrorResponse block_error_response = 2;
inline bool BlockQueryResponse::_internal_has_block_error_response() const {
  return response_case() == kBlockErrorResponse;
}
inline bool BlockQueryResponse::has_block_error_response() const {
  return _internal_has_block_error_response();
}
inline void BlockQueryResponse::set_has_block_error_response() {
  _oneof_case_[0] = kBlockErrorResponse;
}
inline void BlockQueryResponse::clear_block_error_response() {
  if (_internal_has_block_error_response()) {
    if (GetArena() == nullptr) {
      delete response_.block_error_response_;
    }
    clear_has_response();
  }
}
inline ::iroha::protocol::BlockErrorResponse* BlockQueryResponse::release_block_error_response() {
  // @@protoc_insertion_point(field_release:iroha.protocol.BlockQueryResponse.block_error_response)
  if (_internal_has_block_error_response()) {
    clear_has_response();
      ::iroha::protocol::BlockErrorResponse* temp = response_.block_error_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.block_error_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::iroha::protocol::BlockErrorResponse& BlockQueryResponse::_internal_block_error_response() const {
  return _internal_has_block_error_response()
      ? *response_.block_error_response_
      : reinterpret_cast< ::iroha::protocol::BlockErrorResponse&>(::iroha::protocol::_BlockErrorResponse_default_instance_);
}
inline const ::iroha::protocol::BlockErrorResponse& BlockQueryResponse::block_error_response() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.BlockQueryResponse.block_error_response)
  return _internal_block_error_response();
}
inline ::iroha::protocol::BlockErrorResponse* BlockQueryResponse::unsafe_arena_release_block_error_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:iroha.protocol.BlockQueryResponse.block_error_response)
  if (_internal_has_block_error_response()) {
    clear_has_response();
    ::iroha::protocol::BlockErrorResponse* temp = response_.block_error_response_;
    response_.block_error_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlockQueryResponse::unsafe_arena_set_allocated_block_error_response(::iroha::protocol::BlockErrorResponse* block_error_response) {
  clear_response();
  if (block_error_response) {
    set_has_block_error_response();
    response_.block_error_response_ = block_error_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:iroha.protocol.BlockQueryResponse.block_error_response)
}
inline ::iroha::protocol::BlockErrorResponse* BlockQueryResponse::_internal_mutable_block_error_response() {
  if (!_internal_has_block_error_response()) {
    clear_response();
    set_has_block_error_response();
    response_.block_error_response_ = CreateMaybeMessage< ::iroha::protocol::BlockErrorResponse >(GetArena());
  }
  return response_.block_error_response_;
}
inline ::iroha::protocol::BlockErrorResponse* BlockQueryResponse::mutable_block_error_response() {
  // @@protoc_insertion_point(field_mutable:iroha.protocol.BlockQueryResponse.block_error_response)
  return _internal_mutable_block_error_response();
}

inline bool BlockQueryResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void BlockQueryResponse::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline BlockQueryResponse::ResponseCase BlockQueryResponse::response_case() const {
  return BlockQueryResponse::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// HealthcheckData

// uint64 memory_consumption = 1;
inline bool HealthcheckData::_internal_has_memory_consumption() const {
  return opt_memory_consumption_case() == kMemoryConsumption;
}
inline bool HealthcheckData::has_memory_consumption() const {
  return _internal_has_memory_consumption();
}
inline void HealthcheckData::set_has_memory_consumption() {
  _oneof_case_[0] = kMemoryConsumption;
}
inline void HealthcheckData::clear_memory_consumption() {
  if (_internal_has_memory_consumption()) {
    opt_memory_consumption_.memory_consumption_ = PROTOBUF_ULONGLONG(0);
    clear_has_opt_memory_consumption();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HealthcheckData::_internal_memory_consumption() const {
  if (_internal_has_memory_consumption()) {
    return opt_memory_consumption_.memory_consumption_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void HealthcheckData::_internal_set_memory_consumption(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_memory_consumption()) {
    clear_opt_memory_consumption();
    set_has_memory_consumption();
  }
  opt_memory_consumption_.memory_consumption_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HealthcheckData::memory_consumption() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.HealthcheckData.memory_consumption)
  return _internal_memory_consumption();
}
inline void HealthcheckData::set_memory_consumption(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_memory_consumption(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.HealthcheckData.memory_consumption)
}

// bool is_healthy = 2;
inline bool HealthcheckData::_internal_has_is_healthy() const {
  return opt_is_healthy_case() == kIsHealthy;
}
inline bool HealthcheckData::has_is_healthy() const {
  return _internal_has_is_healthy();
}
inline void HealthcheckData::set_has_is_healthy() {
  _oneof_case_[1] = kIsHealthy;
}
inline void HealthcheckData::clear_is_healthy() {
  if (_internal_has_is_healthy()) {
    opt_is_healthy_.is_healthy_ = false;
    clear_has_opt_is_healthy();
  }
}
inline bool HealthcheckData::_internal_is_healthy() const {
  if (_internal_has_is_healthy()) {
    return opt_is_healthy_.is_healthy_;
  }
  return false;
}
inline void HealthcheckData::_internal_set_is_healthy(bool value) {
  if (!_internal_has_is_healthy()) {
    clear_opt_is_healthy();
    set_has_is_healthy();
  }
  opt_is_healthy_.is_healthy_ = value;
}
inline bool HealthcheckData::is_healthy() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.HealthcheckData.is_healthy)
  return _internal_is_healthy();
}
inline void HealthcheckData::set_is_healthy(bool value) {
  _internal_set_is_healthy(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.HealthcheckData.is_healthy)
}

// bool is_syncing = 3;
inline bool HealthcheckData::_internal_has_is_syncing() const {
  return opt_is_syncing_case() == kIsSyncing;
}
inline bool HealthcheckData::has_is_syncing() const {
  return _internal_has_is_syncing();
}
inline void HealthcheckData::set_has_is_syncing() {
  _oneof_case_[2] = kIsSyncing;
}
inline void HealthcheckData::clear_is_syncing() {
  if (_internal_has_is_syncing()) {
    opt_is_syncing_.is_syncing_ = false;
    clear_has_opt_is_syncing();
  }
}
inline bool HealthcheckData::_internal_is_syncing() const {
  if (_internal_has_is_syncing()) {
    return opt_is_syncing_.is_syncing_;
  }
  return false;
}
inline void HealthcheckData::_internal_set_is_syncing(bool value) {
  if (!_internal_has_is_syncing()) {
    clear_opt_is_syncing();
    set_has_is_syncing();
  }
  opt_is_syncing_.is_syncing_ = value;
}
inline bool HealthcheckData::is_syncing() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.HealthcheckData.is_syncing)
  return _internal_is_syncing();
}
inline void HealthcheckData::set_is_syncing(bool value) {
  _internal_set_is_syncing(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.HealthcheckData.is_syncing)
}

// uint64 last_block_height = 4;
inline bool HealthcheckData::_internal_has_last_block_height() const {
  return opt_last_block_height_case() == kLastBlockHeight;
}
inline bool HealthcheckData::has_last_block_height() const {
  return _internal_has_last_block_height();
}
inline void HealthcheckData::set_has_last_block_height() {
  _oneof_case_[3] = kLastBlockHeight;
}
inline void HealthcheckData::clear_last_block_height() {
  if (_internal_has_last_block_height()) {
    opt_last_block_height_.last_block_height_ = PROTOBUF_ULONGLONG(0);
    clear_has_opt_last_block_height();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HealthcheckData::_internal_last_block_height() const {
  if (_internal_has_last_block_height()) {
    return opt_last_block_height_.last_block_height_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void HealthcheckData::_internal_set_last_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_last_block_height()) {
    clear_opt_last_block_height();
    set_has_last_block_height();
  }
  opt_last_block_height_.last_block_height_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HealthcheckData::last_block_height() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.HealthcheckData.last_block_height)
  return _internal_last_block_height();
}
inline void HealthcheckData::set_last_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_block_height(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.HealthcheckData.last_block_height)
}

// uint64 last_block_reject = 5;
inline bool HealthcheckData::_internal_has_last_block_reject() const {
  return opt_last_block_reject_case() == kLastBlockReject;
}
inline bool HealthcheckData::has_last_block_reject() const {
  return _internal_has_last_block_reject();
}
inline void HealthcheckData::set_has_last_block_reject() {
  _oneof_case_[4] = kLastBlockReject;
}
inline void HealthcheckData::clear_last_block_reject() {
  if (_internal_has_last_block_reject()) {
    opt_last_block_reject_.last_block_reject_ = PROTOBUF_ULONGLONG(0);
    clear_has_opt_last_block_reject();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HealthcheckData::_internal_last_block_reject() const {
  if (_internal_has_last_block_reject()) {
    return opt_last_block_reject_.last_block_reject_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void HealthcheckData::_internal_set_last_block_reject(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_last_block_reject()) {
    clear_opt_last_block_reject();
    set_has_last_block_reject();
  }
  opt_last_block_reject_.last_block_reject_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HealthcheckData::last_block_reject() const {
  // @@protoc_insertion_point(field_get:iroha.protocol.HealthcheckData.last_block_reject)
  return _internal_last_block_reject();
}
inline void HealthcheckData::set_last_block_reject(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_block_reject(value);
  // @@protoc_insertion_point(field_set:iroha.protocol.HealthcheckData.last_block_reject)
}

inline bool HealthcheckData::has_opt_memory_consumption() const {
  return opt_memory_consumption_case() != OPT_MEMORY_CONSUMPTION_NOT_SET;
}
inline void HealthcheckData::clear_has_opt_memory_consumption() {
  _oneof_case_[0] = OPT_MEMORY_CONSUMPTION_NOT_SET;
}
inline bool HealthcheckData::has_opt_is_healthy() const {
  return opt_is_healthy_case() != OPT_IS_HEALTHY_NOT_SET;
}
inline void HealthcheckData::clear_has_opt_is_healthy() {
  _oneof_case_[1] = OPT_IS_HEALTHY_NOT_SET;
}
inline bool HealthcheckData::has_opt_is_syncing() const {
  return opt_is_syncing_case() != OPT_IS_SYNCING_NOT_SET;
}
inline void HealthcheckData::clear_has_opt_is_syncing() {
  _oneof_case_[2] = OPT_IS_SYNCING_NOT_SET;
}
inline bool HealthcheckData::has_opt_last_block_height() const {
  return opt_last_block_height_case() != OPT_LAST_BLOCK_HEIGHT_NOT_SET;
}
inline void HealthcheckData::clear_has_opt_last_block_height() {
  _oneof_case_[3] = OPT_LAST_BLOCK_HEIGHT_NOT_SET;
}
inline bool HealthcheckData::has_opt_last_block_reject() const {
  return opt_last_block_reject_case() != OPT_LAST_BLOCK_REJECT_NOT_SET;
}
inline void HealthcheckData::clear_has_opt_last_block_reject() {
  _oneof_case_[4] = OPT_LAST_BLOCK_REJECT_NOT_SET;
}
inline HealthcheckData::OptMemoryConsumptionCase HealthcheckData::opt_memory_consumption_case() const {
  return HealthcheckData::OptMemoryConsumptionCase(_oneof_case_[0]);
}
inline HealthcheckData::OptIsHealthyCase HealthcheckData::opt_is_healthy_case() const {
  return HealthcheckData::OptIsHealthyCase(_oneof_case_[1]);
}
inline HealthcheckData::OptIsSyncingCase HealthcheckData::opt_is_syncing_case() const {
  return HealthcheckData::OptIsSyncingCase(_oneof_case_[2]);
}
inline HealthcheckData::OptLastBlockHeightCase HealthcheckData::opt_last_block_height_case() const {
  return HealthcheckData::OptLastBlockHeightCase(_oneof_case_[3]);
}
inline HealthcheckData::OptLastBlockRejectCase HealthcheckData::opt_last_block_reject_case() const {
  return HealthcheckData::OptLastBlockRejectCase(_oneof_case_[4]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace iroha

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::iroha::protocol::ErrorResponse_Reason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iroha::protocol::ErrorResponse_Reason>() {
  return ::iroha::protocol::ErrorResponse_Reason_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_qry_5fresponses_2eproto
